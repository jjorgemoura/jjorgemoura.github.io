<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"/><meta name="og:site_name" content="Cabulas"/><link rel="canonical" href="https://jjorgemoura.com/extra/books/ModernAutoLayout"/><meta name="twitter:url" content="https://jjorgemoura.com/extra/books/ModernAutoLayout"/><meta name="og:url" content="https://jjorgemoura.com/extra/books/ModernAutoLayout"/><title>Modern Auto Layout | Cabulas</title><meta name="twitter:title" content="Modern Auto Layout | Cabulas"/><meta name="og:title" content="Modern Auto Layout | Cabulas"/><meta name="description" content="I'm an iOS Software Engineer based in London"/><meta name="twitter:description" content="I'm an iOS Software Engineer based in London"/><meta name="og:description" content="I'm an iOS Software Engineer based in London"/><meta name="twitter:card" content="summary"/><link rel="stylesheet" href="/styles.css" type="text/css"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><link rel="shortcut icon" href="/images/favicon.png" type="image/png"/><link rel="alternate" href="/feed.rss" type="application/rss+xml" title="Subscribe to Cabulas"/></head><body><header><div class="wrapper"><a class="site-name" href="/">Cabulas</a><nav><ul><li><a href="/posts">Posts</a></li><li><a href="/articles">Articles</a></li><li><a href="/tips">Tips</a></li></ul></nav></div></header><div class="wrapper"><h1>Modern Auto Layout</h1><h4>by: Keith Harrison</h4><h2>Auto-Layout</h2><p><strong><em>“Auto Layout Is a Constraint-Based, Descriptive Layout System”</em></strong></p><p>The Auto Layout engine produces a layout fitting your description. You have sufficiently described your layout when there’s a single possible solution.</p><p>The <code>NSLayoutAttribute</code> enum gives you a number of choices:</p><ul><li><strong>Edges:</strong> .top, .bottom, .leading, .trailing, .left and .right</li><li><strong>Center:</strong> .centerX and .centerY</li><li><strong>Size:</strong> .width and .height</li></ul><p>The Text Views (<code>UILabel</code>, <code>UITextField</code> and <code>UITextView</code>) elements have 2 extra attributes:</p><ul><li><strong>baseline:</strong> firstBaseLine, lastBaseLine<ul></ul></li></ul><p><strong>Margin Attributes</strong></p><p>Margin attributes for when you want to inset content from the view edges:</p><ul><li><strong>edges:</strong> topMargin, bottomMargin, leadingMargin, trailingMargin</li><li><strong>center:</strong> centerXwithinMargins, centerYwithinMargins</li></ul><p>The challenge when working with Auto Layout is to add just enough constraints to describe a single, unambiguous layout.</p><blockquote><p>You need at least enough constraints to fix the size and position of every view in your view hierarchy.</p></blockquote><p><strong>Creating Constraints In Code</strong></p><p>There are three choices to create constraints in code:</p><ul><li>Use the NSLayoutConstraint class.</li><li>Use the Visual Format Language.</li><li>Use Layout Anchors.</li></ul><p>Activating and deactivating a constraint (<code>isActive</code> property) takes care of adding and removing it from the owning view.</p><p><strong>Note:</strong> It’s a common mistake to activate a constraint between two subviews before you add them both to the view hierarchy. That causes a runtime error because there’s no common superview to own the constraint. Remember to add both views to the same view hierarchy before activating the constraint.</p><p><strong>Note:</strong></p><ul><li>Removing a view from the view hierarchy also removes any constraints that involve that view or any of its subviews.</li></ul><ul><li>Hiding a view doesn’t remove the constraints so you can position views relative to a hidden view.”</li></ul><p><strong>The Autoresizing Mask</strong></p><p>By default, the layout engine will translate the Autoresizing masks to Auto Layout constraints.</p><p>If we use IB to create a view, as soon we add some AL constraint in IB, the translation of the Autoresizing masks into AL is removed.</p><p>However if the view is created programatically, then we need to set <code>view.translatesAutoresisingMaskIntoConstraints = false</code> in order to avoid having those constraints.</p><p><strong>Note:</strong></p><p>It seems we don't need to set this into the main view of a ViewController. The main ViewController's view is already an edge-to-edge view (unless this is a child VC).</p><h3>Creating Constraints</h3><h4>NSLayoutConstraint</h4><p>NSLayoutConstraint(item: view1,	attribute: attr1,	relatedBy: relation,	toItem: view2,	attribute: attr2,	multiplier: m,	constant: c)</p><p>The constraint is <strong>inactive</strong> be default.</p><h4>Visual Format Language</h4><p>Will not pay too much attention to this because is a bit limited and not widely accepted by the community.</p><h4>Layout Anchors</h4><p>This is a new attempt to reduce the verbosity of <code>NSLayoutConstraint</code>. Layout Anchors was introduced in iOS 9.</p><blockquote><p>The NSLayoutAnchor class is a factory class for creating NSLayoutConstraint objects using a fluent API. Use these constraints to programatically define your layout using Auto Layout.</p></blockquote><p>Basically, syntax sugar.</p><p>A <code>UIView</code> has <strong>layout anchors</strong> for each of the <em>Constraint Attributes</em>.</p><p>Each layout anchor is a subclass of <code>NSLayoutAnchor</code> with methods to directly create constraints to other layout anchors of the same type. You don’t use the <code>NSLayoutAnchor</code> class directly. Instead, you use one of its subclasses depending on whether you want to create a horizontal, vertical or size-based constraint:</p><p><strong>Horizontal Constraints</strong></p><p>Use layout anchors of type <code>NSLayoutXAxisAnchor</code> to create horizontal constraints:</p><ul><li>centerXAnchor</li><li>leadingAnchor and trailingAnchor</li><li>leftAnchor and rightAnchor”</li></ul><p><strong>Vertical Constraints</strong></p><p>Use layout anchors of type <code>NSLayoutYAxisAnchor</code> to create vertical constraints:</p><ul><li>centerYAnchor</li><li>bottomAnchor and topAnchor</li><li>firstBaselineAnchor and lastBaselineAnchor</li></ul><p><strong>Size Based Constraints</strong></p><p>Use layout anchors of type <code>NSLayoutDimension</code> to create size-based constraints:</p><ul><li>heightAnchor</li><li>widthAnchor</li></ul><p><strong>NOTE:</strong> It seems the best local to create the AutoLayout Constraints is in <code>viewDidLoad</code> (when we are in a <code>UIViewController</code>). At this point we don't know yet the real screen size however we are just laying down the constraint relationships between all the views. Only in <code>viewDidAppear</code> we know the real screen size.</p><p><strong>NOTE:</strong> In case we are creating UIView's subclass, the AL constraints can and should be set at <code>init</code> time. Of course this make totally sense if we don't alter the view hierarchy later. Even if the change the view hierarchy, probably it just a matter of activate/deactivate constraints.</p><h3>Safe Areas And Layout Margins</h3><p>The main concept here is the new <code>UILayoutGuide</code>. A Layout Guide is a lightweight way to define a rectangular area. It has a layout frame (<code>CGRect</code>), layout anchors that you can create constraints with and an owning view but it’s not part of the view hierarchy.</p><p>Layout guides are used to define default safe areas and margins, but we can also create our own.</p><p>Basically if we want always to use a specific set of margins/padding in all the views, instead of need to setup all the subviews to superview plus a specific margin, we can specify our own custom Layout Guide and then set all the subviews to our layout. Thus, if in the future we need to update the amount of margin/padding, we just need to update the Layout Guide and all the screens that are constrained to our layout will be updated. It is a more consistent solutions when compared with each screen has their own margins and constants.</p><h4>Safe Area Layout Guide</h4><p>Introduced because of iPhone X.</p><p>The <strong>safe area layout guide</strong> is a property of the view. It’s a <code>UILayoutGuide</code> with a <code>layoutFrame</code> and a set of layout anchors that mark out the safe area of the view.</p><p>When using Auto Layout, you create your constraints to the layout anchors of the guide.</p><pre><code>let guide = view.safeAreaLayoutGuide
redView.leadingAnchor.constraint(equalTo: guide.leadingAnchor)
redView.trailingAnchor.constraint(equalTo: guide.trailingAnchor)
</code></pre><p>The <code>safeAreaInsets</code> property of <code>UIView</code> gives you the amount the safe area is inset from the edge of a view.</p><p>We cannot change the safe area layout guide or the safe area insets. However we can increase the safe area using the property <code>additionalSafeAreaInsets</code>.</p><p><strong>Note: </strong> All views have a safe area layout guide property but by default Interface Builder only shows it for the view controller’s root view.</p><h4>Top and Bottom Layout Guides</h4><p>Apple introduced <code>topLayoutGuide</code> and <code>bottomLayoutGuide</code> as properties of UIViewController in iOS 7. Like the safe area, they have layout anchors you can use in your constraints to keep your content away from the status bar and other container views like the navigation and tab bar.</p><p>Unlike the safe area layout guide, they are not of type <code>UILayoutGuide</code>. Instead, they implement the UILayoutSupport protocol which only promises to have a topAnchor, bottomAnchor, heightAnchor and a length.</p><p>This is kind of deprecated.</p><h4>Layout Margins</h4><p>All views have a <strong>margin layout guide</strong> which you can use when you want extra spacing or padding insets from the edge of the view to any content subviews. The <code>layoutMarginsGuide</code> property of a view is a layout guide with the usual set of layout anchors for creating constraints with the margin of the view.</p><h4>Layout Guides</h4><p><strong>Layout guides</strong> cannot be created in <strong>Interface Builder</strong>.</p><p>We can instantiate a new Layout guide and add it to a view. Then, we can play with their layout anchors.</p><p>let leadingGuide = UILayoutGuide()	view.addLayoutGuide(leadingGuide)</p><p>NSLayoutConstraint.activate([	view.leadingAnchor.constraint(equalTo: leadingGuide.leadingAnchor),	...	leadingGuide.widthAnchor.constraint(equalTo: middleGuide.widthAnchor),	leadingGuide.widthAnchor.constraint(equalTo: trailingGuide.widthAnchor),	...</p><h3>Layout Priorities And Content Size</h3><p>asdasd</p></div><footer><p>Generated using <a href="https://github.com/johnsundell/publish">Publish</a></p><p><a href="/feed.rss">RSS feed</a></p></footer></body></html>