<?xml version="1.0" encoding="UTF-8"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/"><channel><title>Swifty Waves</title><description>I'm an iOS Software Engineer</description><link>https://jjorgemoura.github.io</link><language>en</language><lastBuildDate>Tue, 20 Jun 2023 07:56:46 +0000</lastBuildDate><pubDate>Tue, 20 Jun 2023 07:56:46 +0000</pubDate><ttl>250</ttl><atom:link href="https://jjorgemoura.github.io/feed.rss" rel="self" type="application/rss+xml"/><item><guid isPermaLink="true">https://jjorgemoura.github.io/about/cv</guid><title>Resume</title><description></description><link>https://jjorgemoura.github.io/about/cv</link><pubDate>Tue, 20 Jun 2023 07:55:41 +0000</pubDate><content:encoded><![CDATA[<h1>Resume</h1><p>I am a passionate Software Engineer with a wide experience on most of the dimensions of the software development process.</p><p>I have worked from small startups up to big companies, with the highlight of having co-founded and run a software company. All this, in a variety of markets (Retail, Health Care, Public Sector, Media). I have been focusing on the development for iOS since 2014.</p><p>My main motivation is to build quality software, through the adoption of the best development methodologies, tools, design patterns, programming paradigms and testing frameworks.</p>]]></content:encoded></item><item><guid isPermaLink="true">https://jjorgemoura.github.io/about/motivators</guid><title>Motivations and Hobbies</title><description></description><link>https://jjorgemoura.github.io/about/motivators</link><pubDate>Tue, 20 Jun 2023 07:55:41 +0000</pubDate><content:encoded><![CDATA[<h1>Motivations and Hobbies</h1><p>Over the years, I identified things which help me stay motivated and happy.</p><h2>More of this</h2><ul><li>Empathy</li><li>Respect</li></ul><h2>Less of this</h2><ul><li>Arrogance</li><li>Intolerance</li></ul><h2>Personal Values</h2><ul><li>Trust</li><li>Sincere</li></ul>]]></content:encoded></item><item><guid isPermaLink="true">https://jjorgemoura.github.io/tips/swiftOptionals</guid><title>Swift Optionals</title><description>Tips and Tricks: Swift Optinals</description><link>https://jjorgemoura.github.io/tips/swiftOptionals</link><pubDate>Mon, 6 Mar 2023 14:00:00 +0000</pubDate><content:encoded><![CDATA[<p>TODO: Explore the seven ways to deal with Optionals</p><h1>Swift Optionals</h1><p>Swift has introduced (at least for the iOS development ecosystem) the concept of <a href="https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/TheBasics.html#//apple_ref/doc/uid/TP40014097-CH5-ID309">Optionals</a>.</p><p>An optional is a struct that can have two values, a nil value or "a" value.</p><p>From Apple's documentation:</p><blockquote><p>You use optionals in situations where a value may be absent. An optional represents two possibilities: Either there is a value, and you can unwrap the optional to access that value, or there isn’t a value at all.</p></blockquote><p>Along the code we want/need to access those optionals. We can access through several ways:</p><h2>If Statements</h2><p>We can test, using the <code>if</code> statement, if an optinal is nil or not.</p><pre><code class="language-swift">if convertedNumber != nil {
    print("convertedNumber contains some integer value.")
}
</code></pre><p>After testing for <code>nil</code>, if we want to access the value (already knowing that the variable is not nil), we can use the <em>Forced Unwrapping</em>.</p><h2>Forced Unwrapping</h2><p>Basically we force the unwrapping because we "are sure" that the optional contains a value:</p><pre><code class="language-swift">if convertedNumber != nil {
    print("convertedNumber has an integer value of \(convertedNumber!).")
}
// Prints "convertedNumber has an integer value of 123."
</code></pre><p>This is, however, a bit verbose. It can also be dangerous if we avoid the if check based on the logic and in the "feeling" that such optional has a value.</p><h2>Optional Binding</h2><p>Is a more elegant and secure way of doing the unwrapp.</p><pre><code class="language-swift">if let actualNumber = Int(possibleNumber) {
    print("\"\(possibleNumber)\" has an integer value of \(actualNumber)")
} else {
    print("\"\(possibleNumber)\" could not be converted to an integer")
}
// Prints ""123" has an integer value of 123"
</code></pre><p>The main problem is that can be a bit verbose and cause a chain of optional bindings.</p><h2>Implicitly Unwrapped Optionals</h2><p>In some cases it’s clear from an optional will always have a value after some operation(ex: value first set). Thus, it’s useful to remove the need to always check and unwrap the optional’s value. This is because we can assumed that the optional has a value all of the time.</p><p>In that case we can use <em>implicitly unwrapped optionals</em>.</p><pre><code class="language-swift">let possibleString: String? = "An optional string."
let forcedString: String = possibleString! // requires an exclamation mark

let assumedString: String! = "An implicitly unwrapped optional string."
let implicitString: String = assumedString // no need for an exclamation mark
</code></pre><p>This requires some caution because:</p><blockquote><p>If an implicitly unwrapped optional is nil and you try to access its wrapped value, you’ll trigger a runtime error. The result is exactly the same as if you place an exclamation mark after a normal optional that doesn’t contain a value.</p></blockquote>]]></content:encoded></item><item><guid isPermaLink="true">https://jjorgemoura.github.io/tips/protocolNaming</guid><title>Protocol Naming</title><description>Tips and Tricks: Protocol Naming</description><link>https://jjorgemoura.github.io/tips/protocolNaming</link><pubDate>Mon, 6 Mar 2023 13:00:00 +0000</pubDate><content:encoded><![CDATA[<p>TODO: Explore to cover Protocol Witness</p><h1>Protocol Naming</h1><p>While doing some work using the MVVM+Coordinators acchitecture, one of the first problems I have faced was naming, more precisily what to call to ViewModels, both their types (protocol) and implementation classes.</p><p>Of course we can use MVVM without the use of protocols to typify the ViewModels. However, there is n+1 <a href="https://www.raywenderlich.com/148448/introducing-protocol-oriented-programming">articles</a> out there advocating the vantages of <a href="https://developer.apple.com/videos/play/wwdc2015/408/">Protocol-Oriented Programming</a>.</p><p>One of the rules I'm following while using MVVM is refer all the ViewModels through their protocol type.</p><p>This raises, immediatly, the question, how to name both the ViewModel's protocol and complient classes.</p><p>My main rule was try to comply mush as possible with the official recomendations and best practices.</p><p>Apple's <a href="https://swift.org/documentation/api-design-guidelines/">guidelines</a> for protocols are:</p><blockquote><p>Protocols that describe what something is should read as nouns (e.g. Collection). Protocols that describe a capability should be named using the suffixes able, ible, or ing (e.g. Equatable, ProgressReporting).</p></blockquote><p>In our case, that is to name ViewModels, we should read them as nous because their role are being types.</p><h2>First decision</h2><p>Which one should keep the canonical name, the protocol or the class?</p><p>Supposing we have a ViewModel for UserPreferences. Naturally, we will have a UserPreferencesViewModel. Is this UserPreferencesViewModel that I consider the canonical name. So, should UserPreferencesViewModel be the name of the protocol and call something else to all the classes that comply? Or should we call the protocol UserPreferencesViewModelProtocol (or other thing, such: Type) and the UserPreferencesViewModel the default class?</p><p>This decision is pretty easy to make. While the protocol reference will be spread all over the code, the class name will be used just once, during their init. So, it's the protocol that should uise the canonical nomenclature. This is consistent with Apple's rules and practices.</p><h2>Second decision</h2><p>This is the tough one. What to call the classe that actually is our viewModel. One of the Swift code conventions is, do not use abbreviations. This immediatle rule out the Imp / Impl suffix.</p><p>In this type of cases, where we end up one having one implementions (other than the fake one for tests), are the difficult ones. When this happens, I tend to naturally call then as the "default" or "standard" viewModel. However, using those words as prefix doesn't make to much sense and also hurts the readability/searchability of all different kind of classes for a specific feature. Imagine we will have the UserView, UserViewController, UserViewModel, User, UserService and StandardUserViewModel! Doesn't seems tidy.</p><p>I also didn't found a nice suffix, something that reads naturally. The most natural naming always ends with "view model".</p><p>After several tries, I end up calling it "SomethingDefaultViewModel". So, I'm still using the "default" word but move it from being a prefix to be in the middle of the name, just before the "ViewModel". In this particular example, I would use UserDefaultViewModel. Some could argue it's not perfect or that is worse than other options. Fair, but for me it works and fulfill all my rules.</p>]]></content:encoded></item><item><guid isPermaLink="true">https://jjorgemoura.github.io/tips/openClosePrinciple</guid><title>Swift Enums breaks the Open/Close Principle</title><description>Tips and Tricks: Enums and the Open/Close principle</description><link>https://jjorgemoura.github.io/tips/openClosePrinciple</link><pubDate>Mon, 6 Mar 2023 12:00:00 +0000</pubDate><content:encoded><![CDATA[<h1>Swift Enums breaks the Open/Close Principle</h1><p>This idea is analised on this <a href="https://medium.com/@rjchatfield/the-expression-problem-in-swift-6f2471291604">article</a>.</p><p>Basically, my idea, after have read the article is that Swift <code>Enums</code> are bad if <em>"any new case to the enum implies changes in existing case code"</em>.</p><p>Simple as that.</p><p>For more information, is read the articles :)</p><h2>Resouces</h2><p><a href="https://medium.com/@rjchatfield/the-expression-problem-in-swift-6f2471291604">https://medium.com/@rjchatfield/the-expression-problem-in-swift-6f2471291604</a></p><p><a href="https://stackoverflow.com/questions/40396639/swift-extend-an-enum-for-only-one-of-its-cases">https://stackoverflow.com/questions/40396639/swift-extend-an-enum-for-only-one-of-its-cases</a></p>]]></content:encoded></item><item><guid isPermaLink="true">https://jjorgemoura.github.io/tips/logging</guid><title>Logging</title><description>Tips and Tricks: iOS Logging</description><link>https://jjorgemoura.github.io/tips/logging</link><pubDate>Mon, 6 Mar 2023 11:00:00 +0000</pubDate><content:encoded><![CDATA[<h1>Logging</h1>]]></content:encoded></item><item><guid isPermaLink="true">https://jjorgemoura.github.io/tips/failing</guid><title>Failing Swift</title><description>Tips and Tricks: Different ways of failing</description><link>https://jjorgemoura.github.io/tips/failing</link><pubDate>Mon, 6 Mar 2023 10:00:00 +0000</pubDate><content:encoded><![CDATA[<h1>Failing Swift</h1><p>Swift gives us several mechanisms to validate data and handle the execution flow differently based on the type of validation we are doing.</p><p>There are different degrees of severity when we validate data. Most cases this happens when we need to unwrap optionals.</p><p>In some cases we are pretty sure the data is valid but due to the nature of the API, we have an optional that needs to be unwrapped. One very common case is the URL(string:) method, in particular when we provide the url and we are sure the url is valid.</p><p>In other situations, it can be a developer error. In this case is fine to crash the app with a fatal error. The sooner we hit the error the better, it gets fixed.</p><p>So, when facing Errors that should never happen (or if happens is a devs mistake), the correct approach is crash the app.</p><h2>Ways of Failing</h2><p>In Swift, there are 5 different ways we can use if we want to stop the execution of our software (apart from “abort()” or “exit()”). Those are:</p><ul><li>assert</li><li>assertionFailure</li><li>precondition</li><li>preconditionFailure</li><li>fatalError</li></ul><p>One thing that interferes with the way of failing is the “Swift Optimization Levels”.</p><p>There are 3 levels of optimisation:</p><ul><li>-Onone (default for Debug)</li><li>-O (default for release)</li><li>-Ounchecked</li></ul><p>Note: We should not use “-Ounchecked” unless we are really aware of all the implications.</p><h3>assert()</h3><p>If the condition evaluates false, the execution of the code stops.</p><p>Parameters are:</p><ul><li>condition to verify</li><li>message</li><li>file</li><li>line number</li></ul><p>When to use: Should be used internally, privately, as a sanity check tool mainly to catch developers “mistakes”.</p><p>From Apple’s documentation:</p><blockquote><p>Use this function for internal sanity checks that are active during testing but do not impact performance of shipping code. To check for invalid usage in Release builds, see <code>precondition(_:_:file:line:)</code></p></blockquote><p>Visibility: -Onone This means the assert() command is “invisible” in release builds. Is like that line is not even present (in fact that command is not present in release build).</p><h3>assertionFailure()</h3><p>Similar with asset() but doesn’t have the “condition” parameter (used when the test condition is done outside). It stops immediately.</p><p>When to use: same as “assert” but when the test is done outside. Example is, we have more than one command to execute when the validation fails.</p><p>Visibility: -Onone</p><h3>precondition()</h3><p>It has, basically, the same behaviour of the assert() however it is still present in -O builds (typically, the release builds). It has same parameters as “assert()”.</p><p>From Apple’s documentation:</p><blockquote><p>Use this function to detect conditions that must prevent the program from proceeding, even in shipping code.</p></blockquote><p>When to use: Ideally should be used in public APIs, in order to validate parameters.</p><p>Visibility: -Onone and -O</p><h3>preconditionFailure()</h3><p>Follows the same pattern of predecessors.</p><p>When to use: Same as assertFailure().</p><p>Visibility: -Onone and -O</p><h3>fatalerror()</h3><p>This is the more extreme command.</p><p>When to use: when something went really wrong.</p><p>Visibility: -Onone and -O and -Ounchecked</p><h2>Discussion</h2><p>These 5 five ways of failing seems too similar. Main question still remains unanswered. When, if when, should we “crash” in production.</p><p>One possible rationale to follow, based on Swift’s code base (more precisely a comment from Dave Abrahams in a proposal's discussion), is:</p><p>– assert: checking our own code for internal errors. – precondition: checking that external clients have given you valid arguments. This is mainly valid for library’s development.</p><p>Not entirely a rule of thumb (because there are exceptions) but we can simplistically think that preconditions should be used in public methods and asserts in private methods. This also means the preconditions "demands" public documentation.</p><p>Another way of viewing errors and ways of failing is if the error is a <strong>recoverable</strong> or a <strong>non-recoverable</strong> error. All these functions are “non-recoverable”.</p><p>Another way is to distinguish between Developer Errors vs Execution Errors.</p><img src="https://paper-attachments.dropbox.com/s_53DB3428A03BC13C35C0E8B7ED8BAA791EB00ADC4AB1A843B7E28DF6F34DFED1_1571399190336_Screenshot+2019-10-18+at+12.46.21.png"/><h2>Unit testing</h2><p>One tricky point while testing, and in order to get a good coverage, is how to text the “unhappy” path. How can we assert that a “fatalerror” was successfully triggered?</p><p>The solution is via replacing the default fatalError function. In a simple way:</p><ul><li>redefine the function fatalError in our codebase.<ul><li>This function will intercept all calls, not the default Swift implementation.</li><li>create a struct with 4 static “functions”.</li><li>variable holding the current fatalError function.</li><li>a variable with the reference to the default the Swift.fatalError function.</li><li>a function to set a new fatalError implementation to var holding current fatalError function.</li><li>a function that restore the default implementation has the current in use.</li><li>Having the body of our definition of the fatalError() pointing for first var in struct defined just before.</li></ul></li></ul><p>We can follow the same approach for the remaining functions (assert(), assertionFailure(), precondition() and preconditionFailure())</p><h3>XCTUnwrap</h3><p>Handling optionals in Swift could be quite verbose. This is particular notorious while testing, where we control the data and we now there is data. In order to help with these cases, we can now (Xcode 11+) use the function XCTUnwrap().</p><p>From Apple’s documentation:</p><blockquote><p>XCTUnwrap asserts that an optional variable’s value is not nil, returning its value if the assertion succeeds.</p></blockquote><h2>References:</h2><p>https://www.swiftbysundell.com/articles/picking-the-right-way-of-failing-in-swift</p><p>https://ericasadun.com/2015/12/15/interesting-discussions-on-swift-evolution/</p><p>https://agostini.tech/2017/10/01/assert-precondition-and-fatal-error-in-swift/</p><p>https://blog.krzyzanowskim.com/2015/03/09/swift-asserts-the-missing-manual/</p><p>https://medium.com/@marcosantadev/how-to-test-fatalerror-in-swift-e1be9ff11a29</p>]]></content:encoded></item><item><guid isPermaLink="true">https://jjorgemoura.github.io/tips/testingOptionals</guid><title>Testing Optionals</title><description>Tips and Tricks: Testing Optinals</description><link>https://jjorgemoura.github.io/tips/testingOptionals</link><pubDate>Mon, 6 Mar 2023 10:00:00 +0000</pubDate><content:encoded><![CDATA[<p>TODO: Explore PF testing lib</p><h1>Testing Optionals</h1><p>Following Sundell <a href="https://www.swiftbysundell.com/posts/avoiding-force-unwrapping-in-swift-unit-tests">article</a> on <em>Avoiding force unwrapping in Swift unit tests</em>, a cheat sheet can be:</p><h2>Sticking with optionals</h2><p>Use this for the common cases where a method/var is an optional</p><h2>Throwing tests</h2><p>If the method <strong>throws</strong> an error, we should use <code>try</code> to call it. It will crash if it returns nil. The main code will use <code>try?</code>.</p><h2>Encapsulate method to throws error</h2><p>If the method doesn't throws an error (and we don't want or can) add the throws, we can use an encapsulation method (through) an extension in order to replicate the same behaviour.</p>]]></content:encoded></item><item><guid isPermaLink="true">https://jjorgemoura.github.io/tips/errorHandling</guid><title>Error Handling</title><description>Tips and Tricks: Swift's Error Handling</description><link>https://jjorgemoura.github.io/tips/errorHandling</link><pubDate>Mon, 6 Mar 2023 09:00:00 +0000</pubDate><content:encoded><![CDATA[<h1>Error Handling</h1><h2>Representing and Throwing Errors</h2><p>In Swift, errors are represented by values of types that conform to the Error protocol. This empty protocol indicates that a type can be used for error handling.</p><p>The common way to modeling a group of related error conditions is with enumerations, with associated values allowing for additional information about the nature of an error to be communicated. Example:</p><pre><code class="language-swift">enum VendingMachineError: Error {
    case invalidSelection
    case insufficientFunds(coinsNeeded: Int)
    case outOfStock
}
</code></pre><p>Throwing an error allows to indicate that something unexpected happened. The way to throw an error is through the <code>throw</code> keyword.</p><pre><code class="language-swift">throw VendingMachineError.insufficientFunds(coinsNeeded: 5)
</code></pre><p>When a method is able to throw and error, that method needs to be declared as a method that can throw an error in order to call site knows and be ready to handle that error. The way to announce that a method can throw an error, the kwyword <code>throws</code> needs to be present in method declaration.</p><pre><code class="language-swift">func canThrowErrors() throws -&gt; String

func cannotThrowErrors() -&gt; String
</code></pre><h2>Handling Errors</h2><p>There are four ways to handle errors in Swift. When a function throws an error, the calling code (function) can handle the potential error in one of four ways:</p><ul><li>propagate the error from a function to the code that calls that function</li><li>handle the error using a do-catch statement</li><li>handle the error as an optional value</li><li>assert that the error will not occur</li></ul><p>The call sites of every throwing function needs to notice that is calling a throwing function and that something need to be done to handler that error. This is achieved by the use of <code>do-catch</code>, <code>try</code>, <code>try?</code> or <code>try!</code>.</p><h3>propagate the error</h3><p>The call function will not handle the error itself, instead, will throw its self and bypass pass the error to its own call function.</p><pre><code class="language-swift">func buyFavoriteSnack(person: String, vendingMachine: VendingMachine) throws {
    let snackName = favoriteSnacks[person] ?? "Candy Bar"
    
    try vendingMachine.vend(itemNamed: snackName)
}
</code></pre><p>So, <strong>propagate the error from a function to the code that calls that function</strong> means the use of <code>try</code> to call a throwing function and mark it self has a <code>throws</code> function.</p><p><strong>Note:</strong> Not only functions are able to throw errors. Initializers (<code>init</code>) can also throw errors.</p><h3>handle the error using a do-catch statement</h3><p>A <code>do-catch</code> statement allows the calling site to handle errors by running a block of code. If an error is thrown by the code in the do clause, it is matched against the catch clauses to determine which one of them can handle the error.</p><pre><code class="language-swift">var vendingMachine = VendingMachine()
vendingMachine.coinsDeposited = 8
do {
    try buyFavoriteSnack(person: "Alice", vendingMachine: vendingMachine)
    print("Success! Yum.")
} catch VendingMachineError.invalidSelection {
    print("Invalid Selection.")
} catch VendingMachineError.outOfStock {
    print("Out of Stock.")
} catch VendingMachineError.insufficientFunds(let coinsNeeded) {
    print("Insufficient funds. Please insert an additional \(coinsNeeded) coins.")
} catch {
    print("Unexpected error: \(error).")
}
// Prints "Insufficient funds. Please insert an additional 2 coins."
</code></pre><p>The order of the <code>catch</code> statements is important. The error is matched with each statement and, as soon as a match is done, the error will be managed.</p><p>So, <strong>handle the error using a do-catch statement</strong> means a thorough error treatment is done. The call site will handle assume and face the treament of the error.</p><p><strong>Note:</strong> A function can have a <code>do-catch</code> block and still decide to throw/propagate the error to its calling site if decides it is not able to handle it.</p><pre><code class="language-swift">func nourish(with item: String) throws {
    do {
        try vendingMachine.vend(itemNamed: item)
    } catch is VendingMachineError {
        print("Couldn't buy that from the vending machine.")
    }
    // Every error that is not a "VendingMachineError" will be thrown to call site.
}
</code></pre><h3>handle the error as an optional value</h3><p>In case we want to considerar an error thrown by function a function as if the function was returning a <code>nil</code> value, an error can be "converted" to an optional value using <code>try?</code>. If an error is thrown while evaluating the try? expression, the value of the expression is nil.</p><pre><code class="language-swift">func someThrowingFunction() throws -&gt; Int {
    // ...
}

let x = try? someThrowingFunction()

let y: Int?
do {
    y = try someThrowingFunction()
} catch {
    y = nil
}
</code></pre><p>So, <strong>handle the error as an optional value</strong> means an error is as if the function is returning an optional.</p><h3>assert that the error will not occur</h3><p>Sometimes, due to the nature of a specific API, we are confident that a throwing function or method won’t, in fact, throw an error at runtime. On those occasions, we can use <code>try!</code> before the expression to disable error propagation and wrap the call in a runtime assertion that no error will be thrown.</p><p><strong>Note:</strong> Using the <code>try!</code> keyword has a similar effect to <code>Forced Unwrapping</code>. If an error actually is thrown, a runtime error will happen.</p><pre><code class="language-swift">let photo = try! loadImage(atPath: "./Resources/John Appleseed.jpg")
</code></pre><p>In this case, because the image is shipped with the application, no error will be thrown at runtime, so it is appropriate to disable error propagation.</p><p>So, <strong>assert that the error will not occur</strong> means there is confidence an error will never be thown so that possibility is being discarded.</p><h2>Specifying Cleanup Actions</h2><p>If a function needs to perform some "cleaning" after throwing a error, that can be declared through the use for a <code>defer</code> block.</p><pre><code class="language-swift">func processFile(filename: String) throws {
    if exists(filename) {
        let file = open(filename)
        defer {
            close(file)
        }
        while let line = try file.readline() {
            // Work with the file.
        }
        // close(file) is called here, at the end of the scope.
        // This is important to balance with the "open(file)" statement
    }
}
</code></pre><h4>Resources:</h4><p>https://docs.swift.org/swift-book/LanguageGuide/ErrorHandling.html</p>]]></content:encoded></item><item><guid isPermaLink="true">https://jjorgemoura.github.io/tips/designPattersCreational</guid><title>Design Patterns - Creational</title><description>Tips and Tricks: Creational Patterns</description><link>https://jjorgemoura.github.io/tips/designPattersCreational</link><pubDate>Mon, 6 Mar 2023 08:00:00 +0000</pubDate><content:encoded><![CDATA[<h1>Design Patterns - Creational</h1><p>Based on stackoverflow <a href="https://stackoverflow.com/questions/4209791/design-patterns-abstract-factory-vs-factory-method">post</a></p><h2>Static Factory</h2><p>Simple static method in base class.</p><img src="https://i.stack.imgur.com/5txhK.png "static factory"" alt="static factory"/><h2>Simple Factory</h2><p>Basically the same as in previous patterns but now the static method is in their own class.</p><img src="https://i.stack.imgur.com/O4mxc.png "simple factory"" alt="simple factory"/><h2>Factory Method</h2><p>The Simple Factory now delegates in their own subclasses the responsability of creating the classes (all subtypes of the main type).</p><img src="https://i.stack.imgur.com/nyqGK.png "factory method"" alt="factory method"/><h2>Abstract Factory</h2><p>Very similar with previous pattern but now each concrete factory create their own type of classes.</p><img src="https://i.stack.imgur.com/A6riH.png "abstract factory"" alt="abstract factory"/><h2>Resources</h2><p><a href="https://stackoverflow.com/questions/4209791/design-patterns-abstract-factory-vs-factory-method">https://stackoverflow.com/questions/4209791/design-patterns-abstract-factory-vs-factory-method</a></p><p><a href="http://oo-programming.blogspot.co.uk/2009/02/oo-design-principles.html">http://oo-programming.blogspot.co.uk/2009/02/oo-design-principles.html</a></p>]]></content:encoded></item><item><guid isPermaLink="true">https://jjorgemoura.github.io/tips/codeSnippetBuilder</guid><title>Design Patterns -&gt; Builder</title><description>Tips and Tricks: The Builder pattern</description><link>https://jjorgemoura.github.io/tips/codeSnippetBuilder</link><pubDate>Mon, 6 Mar 2023 07:00:00 +0000</pubDate><content:encoded><![CDATA[<h1>Design Patterns -&gt; Builder</h1><p>From Wikipedia: &gt; The builder pattern is an object creation software design pattern. Unlike the abstract factory pattern and the factory method pattern whose intention is to enable polymorphism, the intention of the builder pattern is to find a solution to the telescoping constructor anti-pattern that occurs when the increase of object constructor parameter combination leads to an exponential list of constructors. Instead of using numerous constructors, the builder pattern uses another object, a builder, that receives each initialization parameter step by step and then returns the resulting constructed object at once.</p><p>Another definition is:</p><blockquote><p>The builder pattern is used to create complex objects with constituent parts that must be created in the same order or using a specific algorithm. An external class controls the construction algorithm.</p></blockquote><p>A swift example is:</p><p>For Swift, there are several examples with minor differences. Check [2] and [3] for two very similar examples. The example in [2] we have 2 diffent objects, the class and the build itself. In option [3], it's all done inside the class.</p><p>Option [2]</p><pre><code class="language-swift">class DeathStarBuilder {
    var x: Double?
    var y: Double?
    var z: Double?

    typealias BuilderClosure = (DeathStarBuilder) -&gt; ()

    init(buildClosure: BuilderClosure) {
        buildClosure(self)
    }
}

struct DeathStar : CustomStringConvertible {
    let x: Double
    let y: Double
    let z: Double

    init?(builder: DeathStarBuilder) {
        if let x = builder.x, let y = builder.y, let z = builder.z {
            self.x = x
            self.y = y
            self.z = z
        } else { return nil }
    }
}

//usage
let empire = DeathStarBuilder { builder in
    builder.x = 0.1
    builder.y = 0.2
    builder.z = 0.3
}

let deathStar = DeathStar(builder:empire)
</code></pre><p>Option [3]:</p><pre><code class="language-swift">class Theme : ThemeProtocol {
    var backgroundColor:UIColor?
    var textColor:UIColor?
    
    typealias buildThemeClosure = (Theme) -&gt; Void
    
    init(build:buildThemeClosure) {
        build(self)
    }
}

//usage
let darkTheme = Theme(build: {
    $0.backgroundColor = UIColor.blackColor()
    $0.textColor = UIColor.whiteColor()
})
</code></pre><p>The limitation of option 2 is that the properties need to be public. The properties can not be private.</p><p>The option [3] it's very similar with the current technique to initialise UI classes, as we can see here:</p><pre><code class="language-swift"> let helloWorldLbl:UILabel = {  
    let lbl = UILabel()
    lbl.text = self.someFunctionToDetermineText()
    lbl.font = UIFont.preferredFontForTextStyle(UIFontTextStyleBody)
    lbl.textColor = self.myAppTheme.textColor()
    lbl.textAlignment = .Center
    return lbl
}()
</code></pre><p>In terms of create code snippets, we can have these:</p><pre><code class="language-swift">class &lt;#XPTO#&gt;Builder {

    var x: String?
    var p: Int?
    var t: Bool = false

    typealias BuilderClosure = (&lt;#XPTO#&gt;Builder) -&gt; ()

    init(buildClosure: BuilderClosure) {
        buildClosure(self)
    }
}

class &lt;#XPTO#&gt; {

    let x: String
    let p: Int
    let t: Bool

    init?(builder: &lt;#XPTO#&gt;Builder) {
        if let x = builder.x, let p = builder.p {
            self.x = x
            self.p = p
            self.t = t
        } else {
            return nil
        }
    }
}
</code></pre><p><strong>Side note:</strong> We are now not using the Builder pattern very often. I can't remember exactly why but I think it's because Swift's default parameter capability. This makes that a class initialiser with multiple parameters will not be massive, ugly and difficult to use.</p><h2>Resources</h2><p>1 - <a href="https://en.wikipedia.org/wiki/Builder_pattern">https://en.wikipedia.org/wiki/Builder_pattern</a></p><p>2 - <a href="https://github.com/ochococo/Design-Patterns-In-Swift#creational">https://github.com/ochococo/Design-Patterns-In-Swift#creational</a></p><p>3 - <a href="https://medium.com/swift-programming/the-builder-pattern-in-swift-770d9cc1ac41">https://medium.com/swift-programming/the-builder-pattern-in-swift-770d9cc1ac41</a></p><p>4 - <a href="https://github.com/kingreza/Swift-Builder">https://github.com/kingreza/Swift-Builder</a></p><p>5 - <a href="https://www.raywenderlich.com/86053/intermediate-design-patterns-in-swift">https://www.raywenderlich.com/86053/intermediate-design-patterns-in-swift</a></p>]]></content:encoded></item><item><guid isPermaLink="true">https://jjorgemoura.github.io/tips/apiKeys</guid><title>Securing API Keys and Secrets</title><description>Tips and Tricks: API Keys</description><link>https://jjorgemoura.github.io/tips/apiKeys</link><pubDate>Mon, 6 Mar 2023 06:00:00 +0000</pubDate><content:encoded><![CDATA[<h1>Securing API Keys and Secrets</h1><p>When using 3rd party services, traditionally we need to register our app in 3rd party service and get an API App ID (the app identifier) and also, most of the times, an App Secret (the app login key).</p><p>Usually the App ID is public (or can be treated as public) and can be stored in the app. In terms of security, should not be such big deal if someone access the App ID.</p><p>In terms of App Secret, here we should proceed with maximum careful. We should not store the secret in the code. It will became accessible to anyone through a reverse engineering process.</p><p>The best practice is to store the secret in our server and communicate with our server to retrieve any token (the secret or a token generated with the secret) our integrate with the 3rd party service always through our server-side.</p><p>Of course some services could require the secret only for some actions (write, access sensitive info, etc) and allow the user/app to access some endpoints only with the App ID.</p><p>Note that if someone access our App secret, the attack would only be in app authorisation and access and not the users credentials.</p><p>Online Resources:</p><p><a href="https://developers.facebook.com/docs/facebook-login/security">https://developers.facebook.com/docs/facebook-login/security</a></p><p><a href="https://developer.spotify.com/web-api/authorization-guide/">https://developer.spotify.com/web-api/authorization-guide/</a></p><p><a href="https://steelkiwi.com/blog/how-connect-spotify-sdk-your-project/">https://steelkiwi.com/blog/how-connect-spotify-sdk-your-project/</a></p><p><a href="https://github.com/spotify/ios-sdk/issues/877">https://github.com/spotify/ios-sdk/issues/877</a></p><p><a href="https://github.com/spotify/ios-sdk/issues/159">https://github.com/spotify/ios-sdk/issues/159</a></p><p><a href="https://aaronparecki.com/oauth-2-simplified/">https://aaronparecki.com/oauth-2-simplified/</a></p><p><a href="https://stormpath.com/blog/the-ultimate-guide-to-mobile-api-security">https://stormpath.com/blog/the-ultimate-guide-to-mobile-api-security</a></p><p><a href="https://hackernoon.com/mobile-api-security-techniques-682a5da4fe10">https://hackernoon.com/mobile-api-security-techniques-682a5da4fe10</a></p><p><a href="https://security.stackexchange.com/questions/19989/facebook-api-app-secret-possible-misuse">https://security.stackexchange.com/questions/19989/facebook-api-app-secret-possible-misuse</a></p><p><a href="https://arstechnica.com/information-technology/2010/09/twitter-a-case-study-on-how-to-do-oauth-wrong/">https://arstechnica.com/information-technology/2010/09/twitter-a-case-study-on-how-to-do-oauth-wrong/</a></p><p><a href="https://medium.com/ios-os-x-development/keeping-secrets-out-of-git-in-your-ios-app-c01a357e824b">https://medium.com/ios-os-x-development/keeping-secrets-out-of-git-in-your-ios-app-c01a357e824b</a></p>]]></content:encoded></item><item><guid isPermaLink="true">https://jjorgemoura.github.io/about/website</guid><title>My website</title><description>A description of my first post.</description><link>https://jjorgemoura.github.io/about/website</link><pubDate>Sat, 17 Sep 2022 20:00:00 +0000</pubDate><content:encoded><![CDATA[<h1>My website</h1><p>This is a personal website where I will dump thoughts, ideas and practices I like to follow.</p><p>Under posts I will have Articles and Thoughts</p><p>Under Tips I will have small tips and tricks as well as code snippets.</p>]]></content:encoded></item><item><guid isPermaLink="true">https://jjorgemoura.github.io/posts/projectSetup</guid><title>Xcode Project</title><description>A description of my first post.</description><link>https://jjorgemoura.github.io/posts/projectSetup</link><pubDate>Sat, 17 Sep 2022 20:00:00 +0000</pubDate><content:encoded><![CDATA[<h1>Xcode Project</h1><p>In this article I will detail how I like my Xcode projects to be configured.</p><p>Index:</p><ul><li>LICENSE</li></ul><p>For libraries and sample apps , use MIT.</p><p>For App Store apps, use a custom License agreement based on <a href="https://github.com/pointfreeco/isowords/blob/main/LICENSE.md">isowords' agreement</a>. The idea behind is to allow everything but copy/paste for commercial use.</p><ul><li>gitignore</li></ul><p>Here the base is the template provided by github for Swift.</p><ul><li>Xcode project</li></ul><ul><li>SPM</li></ul><p>For projectr setup, I like to follow the approach <code>Pointfree.co</code> has adopted for the Isowords' codebase.</p><ul><li>Lint and Format (Swiftlint and SwiftFormat)</li></ul><p>To be run locally, via fastlane, or on CI, via GitHub actions.</p><ul><li>Unit Tests</li></ul><ul><li>Xcode Server</li></ul><p>We will use the <strong>free plan</strong> as long as possible, in particular to upload to TestFligh</p><ul><li>Github actions</li></ul><p>We will use github actions for some basic checks, in particular for lint and code format.</p><ul><li>Fastlane</li></ul><p>Fastlane is a really useful and complete tool to help with the build, CI and automation of the project.</p><p>No sure if this is still is the case but, in the past, fastlane support in CI services has not been great, meaning, we needed to use brew to install fastlane. All this delays the build, using precious minutes while using these free tier plans in GitHub and/or Xcode Server.</p><p>Moving forward, will use fastlane mainly for use locally, via command line. Will have the basic functionalities, such as running tests, bump versions, etc.</p>]]></content:encoded></item></channel></rss>