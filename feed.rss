<?xml version="1.0" encoding="UTF-8"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/"><channel><title>Cabulas</title><description>I'm an iOS Software Engineer</description><link>https://jjorgemoura.github.io</link><language>en</language><lastBuildDate>Sat, 19 Jun 2021 14:32:55 +0000</lastBuildDate><pubDate>Sat, 19 Jun 2021 14:32:55 +0000</pubDate><ttl>250</ttl><atom:link href="https://jjorgemoura.github.io/feed.rss" rel="self" type="application/rss+xml"/><item><guid isPermaLink="true">https://jjorgemoura.github.io/tips/failing</guid><title>Failing Swift</title><description>What are the differences between different ways of failing.</description><link>https://jjorgemoura.github.io/tips/failing</link><pubDate>Sat, 19 Jun 2021 11:40:00 +0000</pubDate><content:encoded><![CDATA[<h1>Failing Swift</h1><p>Swift gives us several mechanisms to validate data and handle the execution flow differently based on the type of validation we are doing.</p><p>There are different degrees of severity when we validate data. Most cases this happens when we need to unwrap optionals.</p><p>In some cases we are pretty sure the data is valid but due to the nature of the API, we have an optional that needs to be unwrapped. One very common case is the URL(string:) method, in particular when we provide the url and we are sure the url is valid.</p><p>In other situations, it can be a developer error. In this case is fine to crash the app with a fatal error. The sooner we hit the error the better, it gets fixed.</p><p>So, when facing Errors that should never happen (or if happens is a devs mistake), the correct approach is crash the app.</p><h2>Ways of Failing</h2><p>In Swift, there are 5 different ways we can use if we want to stop the execution of our software (apart from “abort()” or “exit()”). Those are:</p><ul><li>assert</li><li>assertionFailure</li><li>precondition</li><li>preconditionFailure</li><li>fatalError</li></ul><p>One thing that interferes with the way of failing is the “Swift Optimization Levels”.</p><p>There are 3 levels of optimisation:</p><ul><li>-Onone (default for Debug)</li><li>-O (default for release)</li><li>-Ounchecked</li></ul><p>Note: We should not use “-Ounchecked” unless we are really aware of all the implications.</p><h3>assert()</h3><p>If the condition evaluates false, the execution of the code stops.</p><p>Parameters are:</p><ul><li>condition to verify</li><li>message</li><li>file</li><li>line number</li></ul><p>When to use: Should be used internally, privately, as a sanity check tool mainly to catch developers “mistakes”.</p><p>From Apple’s documentation:</p><blockquote><p>Use this function for internal sanity checks that are active during testing but do not impact performance of shipping code. To check for invalid usage in Release builds, see <code>precondition(_:_:file:line:)</code></p></blockquote><p>Visibility: -Onone This means the assert() command is “invisible” in release builds. Is like that line is not even present (in fact that command is not present in release build).</p><h3>assertionFailure()</h3><p>Similar with asset() but doesn’t have the “condition” parameter (used when the test condition is done outside). It stops immediately.</p><p>When to use: same as “assert” but when the test is done outside. Example is we have mode than one command to execute when the validation fails.</p><p>Visibility: -Onone</p><h3>precondition()</h3><p>It has, basically, the same behaviour of the assert() however it is still present in -O builds (typically, the release builds). It has same parameters as “assert()”.</p><p>From Apple’s documentation:</p><blockquote><p>Use this function to detect conditions that must prevent the program from proceeding, even in shipping code.</p></blockquote><p>When to use: Ideally should be used in public APIs, in order to validate parameters.</p><p>Visibility: -Onone and -O</p><h3>preconditionFailure()</h3><p>Follows the same pattern of predecessors.</p><p>When to use: Same as assertFailure().</p><p>Visibility: -Onone and -O</p><h3>fatalerror()</h3><p>This is the more extreme command.</p><p>When to use: when something went really wrong.</p><p>Visibility: -Onone and -O and -Ounchecked</p><h2>Discussion</h2><p>These 5 five ways of failing seems too similar. Main question still remains unanswered. When, if when, should we “crash” in production.</p><p>One possible rationale to follow, based on Swift’s code base (more precisely a comment from Dave Abrahams in a proposal's discussion), is:</p><p>– assert: checking our own code for internal errors. – precondition: checking that external clients have given you valid arguments. This is mainly valid for library’s development.</p><p>Not entirely a rule of thumb (because there are exceptions) but we can simplistically think that preconditions should be used in public methods and asserts in private methods. This also means the preconditions "demands" public documentation.</p><p>Another way of viewing errors and ways of failing is if the error is a <strong>recoverable</strong> or a <strong>non-recoverable</strong> error. All these functions are “non-recoverable”.</p><p>Another way is to distinguish between Developer Errors vs Execution Errors.</p><img src="https://paper-attachments.dropbox.com/s_53DB3428A03BC13C35C0E8B7ED8BAA791EB00ADC4AB1A843B7E28DF6F34DFED1_1571399190336_Screenshot+2019-10-18+at+12.46.21.png"/><h2>Unit testing</h2><p>One tricky point while testing, and in order to get a good coverage, is how to text the “unhappy” path. How can we assert that a “fatalerror” was successfully triggered?!</p><p>The solution is via replacing the default fatalError function. In a simple way:</p><ul><li>redefine the function fatalError in our codebase.<ul><li>This function will intercept all calls, not the default Swift implementation.</li><li>create a struct with 4 static “functions”.</li><li>variable holding the current fatalError function.</li><li>a variable with the reference to the default the Swift.fatalError function.</li><li>a function to set a new fatalError implementation to var holding current fatalError function.</li><li>a function that restore the default implementation has the current in use.</li><li>Having the body of our definition of the fatalError() pointing for first var in struct defined just before.</li></ul></li></ul><p>We can follow the same approach for the remaining functions (assert(), assertionFailure(), precondition() and preconditionFailure())</p><h3>XCTUnwrap</h3><p>Handling optionals in Swift could be quite verbose. This is particular notorious while testing, where we control the data and we now there is data. In order to help with these cases, we can now (Xcode 11+) use the function XCTUnwrap().</p><p>From Apple’s documentation:</p><blockquote><p>XCTUnwrap asserts that an optional variable’s value is not nil, returning its value if the assertion succeeds.</p></blockquote><h2>References:</h2><p>https://www.swiftbysundell.com/articles/picking-the-right-way-of-failing-in-swift</p><p>https://ericasadun.com/2015/12/15/interesting-discussions-on-swift-evolution/</p><p>https://agostini.tech/2017/10/01/assert-precondition-and-fatal-error-in-swift/</p><p>https://blog.krzyzanowskim.com/2015/03/09/swift-asserts-the-missing-manual/</p><p>https://medium.com/@marcosantadev/how-to-test-fatalerror-in-swift-e1be9ff11a29</p>]]></content:encoded></item><item><guid isPermaLink="true">https://jjorgemoura.github.io/tips/errorHandling</guid><title>Error Handling</title><description>Swift's Error handling.</description><link>https://jjorgemoura.github.io/tips/errorHandling</link><pubDate>Sat, 19 Jun 2021 11:30:00 +0000</pubDate><content:encoded><![CDATA[<h1>Error Handling</h1><h2>Representing and Throwing Errors</h2><p>In Swift, errors are represented by values of types that conform to the Error protocol. This empty protocol indicates that a type can be used for error handling.</p><p>The common way to modeling a group of related error conditions is with enumerations, with associated values allowing for additional information about the nature of an error to be communicated. Example:</p><pre><code class="language-swift">enum VendingMachineError: Error {
    case invalidSelection
    case insufficientFunds(coinsNeeded: Int)
    case outOfStock
}
</code></pre><p>Throwing an error allows to indicate that something unexpected happened. The way to throw an error is through the <code>throw</code> keyword.</p><pre><code class="language-swift">throw VendingMachineError.insufficientFunds(coinsNeeded: 5)
</code></pre><p>When a method is able to throw and error, that method needs to be declared as a method that can throw an error in order to call site knows and be ready to handle that error. The way to announce that a method can throw an error, the kwyword <code>throws</code> needs to be present in method declaration.</p><pre><code class="language-swift">func canThrowErrors() throws -&gt; String

func cannotThrowErrors() -&gt; String
</code></pre><h2>Handling Errors</h2><p>There are four ways to handle errors in Swift. When a function throws an error, the calling code (function) can handle the potential error in one of four ways:</p><ul><li>propagate the error from a function to the code that calls that function</li><li>handle the error using a do-catch statement</li><li>handle the error as an optional value</li><li>assert that the error will not occur</li></ul><p>The call sites of every throwing function needs to notice that is calling a throwing function and that something need to be done to handler that error. This is achieved by the use of <code>do-catch</code>, <code>try</code>, <code>try?</code> or <code>try!</code>.</p><h3>propagate the error</h3><p>The call function will not handle the error itself, instead, will throw its self and bypass pass the error to its own call function.</p><pre><code class="language-swift">func buyFavoriteSnack(person: String, vendingMachine: VendingMachine) throws {
    let snackName = favoriteSnacks[person] ?? "Candy Bar"
    
    try vendingMachine.vend(itemNamed: snackName)
}
</code></pre><p>So, <strong>propagate the error from a function to the code that calls that function</strong> means the use of <code>try</code> to call a throwing function and mark it self has a <code>throws</code> function.</p><p><strong>Note:</strong> Not only functions are able to throw errors. Initializers (<code>init</code>) can also throw errors.</p><h3>handle the error using a do-catch statement</h3><p>A <code>do-catch</code> statement allows the calling site to handle errors by running a block of code. If an error is thrown by the code in the do clause, it is matched against the catch clauses to determine which one of them can handle the error.</p><pre><code class="language-swift">var vendingMachine = VendingMachine()
vendingMachine.coinsDeposited = 8
do {
    try buyFavoriteSnack(person: "Alice", vendingMachine: vendingMachine)
    print("Success! Yum.")
} catch VendingMachineError.invalidSelection {
    print("Invalid Selection.")
} catch VendingMachineError.outOfStock {
    print("Out of Stock.")
} catch VendingMachineError.insufficientFunds(let coinsNeeded) {
    print("Insufficient funds. Please insert an additional \(coinsNeeded) coins.")
} catch {
    print("Unexpected error: \(error).")
}
// Prints "Insufficient funds. Please insert an additional 2 coins."
</code></pre><p>The order of the <code>catch</code> statements is important. The error is matched with each statement and, as soon as a match is done, the error will be managed.</p><p>So, <strong>handle the error using a do-catch statement</strong> means a thorough error treatment is done. The call site will handle assume and face the treament of the error.</p><p><strong>Note:</strong> A function can have a <code>do-catch</code> block and still decide to throw/propagate the error to its calling site if decides it is not able to handle it.</p><pre><code class="language-swift">func nourish(with item: String) throws {
    do {
        try vendingMachine.vend(itemNamed: item)
    } catch is VendingMachineError {
        print("Couldn't buy that from the vending machine.")
    }
    // Every error that is not a "VendingMachineError" will be thrown to call site.
}
</code></pre><h3>handle the error as an optional value</h3><p>In case we want to considerar an error thrown by function a function as if the function was returning a <code>nil</code> value, an error can be "converted" to an optional value using <code>try?</code>. If an error is thrown while evaluating the try? expression, the value of the expression is nil.</p><pre><code class="language-swift">func someThrowingFunction() throws -&gt; Int {
    // ...
}

let x = try? someThrowingFunction()

let y: Int?
do {
    y = try someThrowingFunction()
} catch {
    y = nil
}
</code></pre><p>So, <strong>handle the error as an optional value</strong> means an error is as if the function is returning an optional.</p><h3>assert that the error will not occur</h3><p>Sometimes, due to the nature of a specific API, we are confident that a throwing function or method won’t, in fact, throw an error at runtime. On those occasions, we can use <code>try!</code> before the expression to disable error propagation and wrap the call in a runtime assertion that no error will be thrown.</p><p><strong>Note:</strong> Using the <code>try!</code> keyword has a similar effect to <code>Forced Unwrapping</code>. If an error actually is thrown, a runtime error will happen.</p><pre><code class="language-swift">let photo = try! loadImage(atPath: "./Resources/John Appleseed.jpg")
</code></pre><p>In this case, because the image is shipped with the application, no error will be thrown at runtime, so it is appropriate to disable error propagation.</p><p>So, <strong>assert that the error will not occur</strong> means there is confidence an error will never be thown so that possibility is being discarded.</p><h2>Specifying Cleanup Actions</h2><p>If a function needs to perform some "cleaning" after throwing a error, that can be declared through the use for a <code>defer</code> block.</p><pre><code class="language-swift">func processFile(filename: String) throws {
    if exists(filename) {
        let file = open(filename)
        defer {
            close(file)
        }
        while let line = try file.readline() {
            // Work with the file.
        }
        // close(file) is called here, at the end of the scope.
        // This is important to balance with the "open(file)" statement
    }
}
</code></pre><h4>Resources:</h4><p>https://docs.swift.org/swift-book/LanguageGuide/ErrorHandling.html</p>]]></content:encoded></item><item><guid isPermaLink="true">https://jjorgemoura.github.io/articles/libraries</guid><title>Libraries and Frameworks</title><description>What are the differences between Libraries and Frameworks and also between static and dynamic</description><link>https://jjorgemoura.github.io/articles/libraries</link><pubDate>Sat, 19 Jun 2021 11:20:00 +0000</pubDate><content:encoded><![CDATA[<h1>Libraries and Frameworks</h1><p>After all these years, I keep struggling with the differences (real or just nomenclature) on libraries.</p><p>What's the difference between a Library, a Framework, a Module and a package?</p><p>What's the difference between Static, Dynamic and Shared?</p><h2>The diffent flavours of modularization</h2><p>A library is a piece of code that doesn't belong to our main code. It's something that is external to our project and that we need, in order to use it, to reference (or linking).</p><h3>Module</h3><p>Is the smallest piece of software. A module is a set of methods or functions ready to be used somewhere else.</p><p>In the iOS world, a module is a "<em>target</em>", i.e. something that is declared as a library/framework or an app (or a test target). When we need to use the "import" keyword, that means we are importing a module. Can be the main app/target or a library/framework.</p><p>A module can be also used as a <em>generic</em> name for a library or a framework.</p><p>From Apple's SPM page:</p><blockquote><p>Swift organizes code into modules. Each module specifies a namespace and enforces access controls on which parts of that code can be used outside of the module.</p></blockquote><blockquote><p>A program may have all of its code in a single module, or it may import other modules as dependencies. Aside from the handful of system-provided modules, such as Darwin on macOS or Glibc on Linux, most dependencies require code to be downloaded and built in order to be used.</p></blockquote><blockquote><p>When you use a separate module for code that solves a particular problem, that code can be reused in other situations. For example, a module that provides functionality for making network requests can be shared between a photo sharing app and a weather app. Using modules lets you build on top of other developers’ code rather than reimplementing the same functionality yourself.</p></blockquote><h3>Package</h3><p>Is a collection of modules. A package gathers a number of modules holding in general the same functional purpose. It is easier to include all the related modules at once.</p><p>In the iOS world, a package is quite related with <a href="https://swift.org/package-manager/">Swift Package Manager</a>. Similar with modules, it feels a package can also be a "generic" term for a library or a framework.</p><p>In <a href="https://swift.org/package-manager/">Swift Package Manager</a> page, we can read:</p><blockquote><p>A package consists of Swift source files and a manifest file. The manifest file, called Package.swift, defines the package’s name and its contents using the PackageDescription module.</p></blockquote><blockquote><p>A package has one or more targets. Each target specifies a product and may declare one or more dependencies.</p></blockquote><p>So, yes, the package can hold multiple modules (targets)</p><h3>Library</h3><p>Both frameworks and libraries are code written by someone else that is used to help solve common problems.</p><p>There isn’t anything magic about frameworks or libraries. Both libraries and frameworks are reusable code written by someone else. Their purpose is to help us solving common problems in easier ways.</p><p>A library is just a collection of related functionality. Nothing more, but also nothing less. The defining characteristic of a library is that you are in control, you call the library.</p><p>The process of merging external libraries with app’s source code files is known as linking.</p><h3>Framework</h3><p>Quite similar with a Library. However, the defining characteristic of a framework is Inversion of Control. The framework calls you, not the other way round. (This is known as the Hollywood Principle: "Don't call us, we'll call you."). The framework is in control. The flow of control and the flow of data is managed by the framework.</p><p>Framework is a package that can contain resources such as dynamic libraries, strings, headers, images, storyboards etc. With small changes to its structure, it can even contain other frameworks. Such aggregate is known as umbrella framework.</p><p>Frameworks are also bundles ending with .framework extension. They can be accessed by NSBundle / Bundle class from code and, unlike most bundle files, can be browsed in the file system that makes it easier for developers to inspect its contents. Frameworks have versioned bundle format which allows to store multiple copies of code and headers to support older program version</p><h3>Library vs Framework</h3><p>When you use a library, we are in charge of the flow of the application. We are choosing when and where to call the library. When we use a framework, the framework is in charge of the flow. It provides some places for us to plug in our code, but it calls the code we plugged in as needed.</p><p>In both cases, there is an application, and this application has holes in it, where code has been left out, and these holes need to be filled in. The difference between a library and a framework is:</p><ul><li>who writes the application,</li><li>what are the holes and</li><li>who fills in the holes.</li></ul><p>With a library, you write the application, and you leave out the boring details, which gets filled in by a library. With a framework, the framework writer writes the application, and leaves out the interesting details, which you fill in. This can be a little confusing at times, because the framework itself might also contain boring details, that the framework author filled in with libraries, the parts that you write might contain boring details, that you fill in with libraries, and the framework might provide a set of bundled libraries that either work well with the framework or that are often needed in conjunction with the framework. For example, you might use an XML generator library when writing a web application using a web framework, and that XML library might have been provided by the framework or even be an integral part of it.</p><p>That doesn't mean, however, that there is no distinction between a library and a framework. The distinction is very clear: Inversion of Control is what it's all about.</p><p>So, let's recap:</p><ul><li>library: collection of related functionality</li><li>framework: Inversion of Control</li></ul><p>Can I create a Library and have it behave as framework or vice-versa?</p><p>Probably we can have a basic framework that could have been just a library. Not the other way around. A Library can only contain code, functions. On the other hand, a framework is basically another program inside the main program. Can have resources. It lives inside the main app.</p><p>A Library doesn't have version, bundle ID, etc.</p><h2>Static vs Dynamic</h2><p>Let's start with the fundamental programmatically difference, the Static vs Dynamic.</p><p>If the linking is done at compile time, with the external code being included in our build, this means we are statically referencing a library. Otherwise, if we don't have the code in our build, this means the linking is done at runtime, dynamically.</p><p>Libraries fall into two categories based on how they are linked to the app:</p><ul><li>Static libraries — .a</li><li>Dynamic libraries — .dylib</li></ul><h3>Static Library</h3><p>A collection or archive of object files. Static linker collects app compiled source code with library code into a single executable file, which loads into memory in its entirety at runtime.</p><p>Static libraries are ending with .a suffix and are created with an archiver tool. If it sounds very similar to a ZIP archive, then it’s exactly what it is.</p><p>Since static library, basically, is a sequence of statements or instructions in a machine code language (Object files have Mach-O format), this means some limitations to create and distribute them:</p><ul><li>needs to build a library for the same processor architecture as the client code. When working on a library for the iOS application, it will be needed to create a library for iOS Simulator and iOS devices.</li></ul><ul><li>The library can’t include resource files: images, assets, nibs, strings file and other visual data. Usually a potential solution to this problem group all related external resources provided within another independent bundle.</li></ul><h4>Pros and cons</h4><p>✓ Pros:</p><ul><li>Static libraries are guaranteed to be present in the app and have correct version.</li><li>No need to keep an app up to date with library updates.</li><li>Better performance of library calls.</li></ul><p>✕ Cons:</p><ul><li>Inflated app size.</li><li>Launch time degrades because of bloated app executable.</li><li>Must copy whole library even if using single function.</li></ul><h3>Dynamic Library</h3><p>Dynamic libraries, as opposed to the static ones, rather than being copied into single monolithic executable, are loaded into memory when they are actually needed. This could happen either at load time or at runtime.</p><p>Dynamic libraries are usually shared between applications, therefore the system needs to store only one copy of the library and let different processes access it. As a result, invoking code and data from dynamic libraries happens slower than from the static ones.</p><p>All iOS and macOS system libraries are dynamic. Hence our apps will benefit from the future improvements that Apple makes to standard library frameworks without creating and shipping new builds.</p><h4>Pros and cons</h4><p>✓ Pros:</p><ul><li>Can benefit from library improvements without app re-compile. Especially useful with system libraries.</li><li>Takes less disk space, since it is shared between applications.</li><li>Faster startup time, as it is loaded on-demand during runtime.</li><li>Loaded by pieces: no need to load whole library if using single function.</li></ul><p>✕ Cons:</p><ul><li>Can potentially break the program if anything changes in the library.</li><li>Slower calls to library functions, as it is located outside application executable.</li></ul><h3>Frameworks</h3><p>Basically the same applies to frameworks as is with Libraries. They can be static or dynamic.</p><h3>Who decides what</h3><p>An important question is, how defines if a library is static or dynamic? Is the library itself or is in the consumer, at the moment the library is included in consumer project?</p><p>Eventually we will want a library to be statically included in some projects and dynamically included in others.</p><p>It seems the consumer apps have the tools and the power to decide to include a library/framework statically or dynamically.</p><h3>Discussion</h3><p>This is not a simple question. After reading and watching tons of information, it's still unclear what the difference between a library and framework (in particular since SPM hasintroduced (in 2020) the possibility of a library to have resources [1]).</p><p>Note [1]: I wonder if the SPM's resources support is not, behind the scenes, keeping the vanilla library and just automate the generation of a bundle to include all the resources.</p><p>It is also important to discuss the settings available in Xcode, in particular the <code>embed</code> options and the build settings that says how to include the library.</p><h2>My Tips</h2><p>Againg, there is still multiple unkwonws to me regrading the best pratices or procedures regarding the use of libraries vs frameworks, static vs dynamic binding.</p><p>Without a doubt, SMP is a really tool when compared with Cocoapods. Thus, we should prioritize SPM over Cocoapods. Unfortunatelly, not all dependencies are SPM ready.</p><p><strong>Types:</strong></p><p><strong>Rule #1</strong> - For internal modules, start with a SPM.</p><p><strong>Rule #2</strong> - For external modules, use SPM if available.</p><p><strong>Rule #3</strong> - For external modules, if SPM is not available, consider Carthage to manage the dependency (this requires some manual setup)</p><p><strong>Rule #4</strong> - If, by any change, SPM doesn't fullfil the needs for internal modules, switch for a framework (but manage it locally and manually).</p><p><strong>Golden Rule</strong> - Avoid Cocoapods at all costs.</p><p><strong>Binding</strong></p><p><strong>Rule #1</strong> - If the module is fundaitional, use static. It takes more time to load but that time will be recover because that module is needed from step 1.</p><p><strong>Rule #2</strong> - If the module is only use in a specific part of the app that doesn't belong to typically flow, use dynamic. It takes less time to load app. Only when the user will use that resource (if that happens), the system will load the dynamic framework.</p><h2>Other stuff</h2><p>Swift Package Manager only manages open source libraries. In order to be able to manage bynary frameworks, Apple has introduced <strong>XCFramework</strong>. Binary in this context means compiled/closed source code.</p><p>A <strong>XCFramework</strong> wrappes an binary module.</p><p><strong>Xcode 11</strong></p><ul><li>Swift packages -&gt; To distribute libraries as open source code</li><li>XCFrameworks -&gt; To distribute closed source code binary frameworks and libraries</li></ul><p><strong>Xcode 12</strong></p><ul><li>Add support (bring the advantages) on Swift Packages for the distribution of closed source, with support for binary dependencies.</li></ul><h2>Resources</h2><ul><li>https://medium.com/@zippicoder/libraries-frameworks-swift-packages-whats-the-difference-764f371444cd</li></ul><p>Anurag Ajwani</p><ul><li>https://medium.com/onfido-tech/reusing-code-with-swift-frameworks-cf60f5fa288a</li><li>https://medium.com/onfido-tech/distributing-swift-frameworks-via-cocoapods-152002b41783</li><li>https://medium.com/onfido-tech/distributing-compiled-swift-frameworks-via-cocoapods-8cb67a584d57</li><li>https://medium.com/onfido-tech/reusing-code-and-resources-with-swift-static-libraries-and-resource-bundles-d070e82d3b3d</li><li>https://medium.com/onfido-tech/distributing-compiled-ios-swift-static-libraries-and-swift-static-frameworks-7fecc4f3d182</li><li>https://medium.com/better-programming/distributing-ios-swift-libraries-with-swift-package-manager-3c9630149bb3</li><li>https://medium.com/@anuragajwani/how-to-build-universal-ios-frameworks-74b6b07bf31d</li><li>https://medium.com/@anuragajwani/how-to-build-universal-ios-frameworks-using-xcframeworks-4c2790cfa623</li><li>https://medium.com/@anuragajwani/how-to-distribute-compiled-static-frameworks-via-cocoapods-817a4c57cb10</li><li>https://medium.com/@anuragajwani/how-to-distribute-compiled-universal-ios-xcframeworks-using-swift-package-manager-8eaf8395985f</li><li>https://medium.com/@anuragajwani/how-to-build-universal-ios-static-libraries-using-xcframework-a3f70f998c38</li><li>https://medium.com/@anuragajwani/distributing-universal-ios-frameworks-as-xcframeworks-using-cocoapods-699c70a5c961</li><li>https://medium.com/@anuragajwani/distributing-compiled-universal-ios-static-libraries-as-xcframeworks-via-cocoapods-9d5c0f8b6a21</li><li>https://medium.com/@anuragajwani/modular-ios-guide-60810f5a7f97</li></ul><p>Apple</p><ul><li>https://developer.apple.com/library/archive/documentation/DeveloperTools/Conceptual/DynamicLibraries/100-Articles/OverviewOfDynamicLibraries.html</li></ul><ul><li>https://developer.apple.com/library/archive/technotes/tn2435/<em>index.html#//apple</em>ref/doc/uid/DTS40017543-CH1-PROJ<em>CONFIG-APPS</em>WITH<em>DEPENDENCIES</em>BETWEEN_FRAMEWORKS</li></ul><ul><li>https://developer.apple.com/library/archive/documentation/MacOSX/Conceptual/BPFrameworks/Tasks/CreatingFrameworks.html#//apple_ref/doc/uid/20002258-BAJDHDAF</li></ul><ul><li>https://developer.apple.com/library/archive/documentation/CoreFoundation/Conceptual/CFBundles/BundleTypes/BundleTypes.html#//apple_ref/doc/uid/10000123i-CH101-SW1</li></ul><ul><li>https://developer.apple.com/documentation/xcode/creating<em>a</em>standalone<em>swift</em>package<em>with</em>xcode</li></ul><p>More</p><ul><li>https://pewpewthespells.com/blog/static<em>and</em>dynamic_libraries.html</li></ul><ul><li>https://medium.com/ios-expert-series-or-interview-series/ios-app-launch-static-binding-vs-dynamic-binding-linking-vs-embedded-e69ea9f03f72</li></ul><ul><li>https://stackoverflow.com/questions/15331056/library-static-dynamic-or-framework-project-inside-another-project</li></ul><p>Others</p><ul><li>https://medium.com/flawless-app-stories/improve-your-ios-teams-productivity-by-building-features-as-frameworks-9d2a64cbcab5</li><li>https://tech.just-eat.com/2019/12/18/modular-ios-architecture-just-eat/</li><li>https://ricardojpsantos.medium.com/building-and-end-to-end-encryption-framework-in-swift-cff7c8909130</li><li>https://stackoverflow.com/questions/4099975/difference-between-a-module-library-and-a-framework</li><li>https://www.freecodecamp.org/news/the-difference-between-a-framework-and-a-library-bd133054023f/</li><li>https://medium.com/ieee-ensias-student-branch/framework-vs-library-vs-package-vs-module-the-debate-e1013a3e114d</li><li>https://medium.com/joshtastic-blog/frameworks-and-libraries-in-swift-2359e4274faa</li><li>https://engineering.zalando.com/posts/2017/02/how-the-zalando-ios-app-abandoned-cocoapods-and-reduced-build-time.html</li><li>https://medium.com/@acecilia/static-vs-dynamic-frameworks-in-swift-an-in-depth-analysis-ff61a77eec65</li><li>https://www.vadimbulavin.com/static-dynamic-frameworks-and-libraries/</li><li>https://stackoverflow.com/questions/27899799/ios-static-vs-dynamic-frameworks-clarifications</li></ul>]]></content:encoded></item><item><guid isPermaLink="true">https://jjorgemoura.github.io/articles/compileTime</guid><title>Xcode/Swift Compile Time</title><description>How to improve compile time.</description><link>https://jjorgemoura.github.io/articles/compileTime</link><pubDate>Sat, 19 Jun 2021 11:10:00 +0000</pubDate><content:encoded><![CDATA[<h1>Xcode/Swift Compile Time</h1><p>I'm following <a href="https://useyourloaf.com/blog/slow-swift-compiler-performance/">this article</a>.</p><p>One important information is that the building times reported can be longer than the total compilation time. This is due to paralelization of the compilation.</p><blockquote><p>Yes – many commands, especially compilation, are able to run in parallel with each other, so multicore machines will finish the build much faster than the time it took to run each of the commands.</p></blockquote><h2>Indentify some culprits</h2><h3>xcodebuild flags</h3><p>Run the command</p><pre><code>xcodebuild -workspace ArticleUIKit.xcworkspace -scheme ArticleUIKit clean build OTHER_SWIFT_FLAGS="-Xfrontend -debug-time-function-bodies" | grep .[0-9]ms | grep -v ^0.[0-9]ms | sort -nr &gt; culprits.txt
</code></pre><p>note: the command is not 100%, several duplicated lines.</p><h3>Xcode flags</h3><p>Flags we can use to identify compilation bottlenecks directly in Xcode. Add the flags in the build settings for a target in the <strong>Swift Compiler - Custom Flags</strong> section using the <strong>Other Swift Flags</strong> setting::</p><pre><code>    -Xfrontend -warn-long-function-bodies=&lt;limit&gt;
    -Xfrontend -warn-long-expression-type-checking=&lt;limit&gt;
</code></pre><h3>Xcode Build with Timming</h3><p>Xcode has an option to compile with timming information.</p><p><code>Product -&gt; Perform Action -&gt; Build with Timming Summary</code></p><p>Note: The is also a flag for <code>xcodebuild</code>: <code>-buildWithTimingSummary</code></p><h2>Fixes</h2><p>Identifiying methods that take more time to compile is a first step. Next, we need to try to improve the compilation time. Not always it's easy or possible to improve those times.</p><p>It seems one of the things it takes some significat time to compile is operators overload. Things such as <code>x + y</code> takes quite a time because Swift needs to seach for declarations for all the types because the variables <code>x</code> and <code>y</code> can be <code>Ints</code>, <code>Doubles</code>, <code>Strings</code>, <code>Arrays</code>, etc.</p><p>Most all the issues are multiplication of Floats/CGFloats.</p><h4>Resources:</h4><p>https://useyourloaf.com/blog/slow-swift-compiler-performance/</p><p>https://www.avanderlee.com/optimization/analysing-build-performance-xcode/</p><p>https://irace.me/swift-profiling</p><p>https://www.cocoawithlove.com/blog/2016/07/12/type-checker-issues.html</p>]]></content:encoded></item><item><guid isPermaLink="true">https://jjorgemoura.github.io/posts/first-post</guid><title>My first post 2</title><description>A description of my first post.</description><link>https://jjorgemoura.github.io/posts/first-post</link><pubDate>Sat, 19 Jun 2021 11:08:00 +0000</pubDate><content:encoded><![CDATA[<h1>My first post 2</h1><p>My first post's text.</p>]]></content:encoded></item><item><guid isPermaLink="true">https://jjorgemoura.github.io/articles/appLaunchTime</guid><title>App Launch time</title><description>Settings and techniques to retrieve and analyse information about App launch time</description><link>https://jjorgemoura.github.io/articles/appLaunchTime</link><pubDate>Sat, 19 Jun 2021 11:00:00 +0000</pubDate><content:encoded><![CDATA[<h1>App Launch time</h1><p>I'm following <a href="https://medium.com/globant/ios-app-launch-time-analysis-and-optimization-a219ee81447c">this article</a>.</p><h2>Pre-Main</h2><h3>Frameworks</h3><p>In order to improve the startup time, the time before <code>main</code> is called, we need to:</p><ul><li>Do less<ul><li>Embed fewer dylibs</li><li>Declare fewer classes/methods</li><li>Use fewer initializers (not sure what this means, it is not class/struct's <code>init</code>s)</li><li>Use more Swift (because):</li><li>has "no initializers"</li><li>size improvements</li></ul></li></ul><h4>Initializers</h4><p>It seems initializers is a Objective-C feature where a Library/Module may define some code to be executed when the Library is setup up (linked).</p><p>Based on <a href="https://developer.apple.com/library/archive/documentation/DeveloperTools/Conceptual/DynamicLibraries/100-Articles/DynamicLibraryDesignGuidelines.html">this</a> document, initialisers are defined as:</p><pre><code class="language-c">/* Files: File1.c, File2.c */
#include &lt;stdio.h&gt;
__attribute__((constructor))
static void initializer1() {
    printf("[%s] [%s]\n", __FILE__, __FUNCTION__);
}
</code></pre><p>It seems Swift doesn't have this functionality.</p><p>Note: On WWDC 2017 it was launched <strong>dyld 3</strong>.</p><p>In <strong>dyld 3</strong>, some features are:</p><ul><li>Move complex operations out of process<ul><li>Most of dyld is now a regular daemon</li><li>Make the rest of dyld as small as possible</li><li>Reduces attack surface</li><li>Speeds up launch<ul><li>The fastest code is code you never write</li><li>Followed closely by code you almost never execute</li></ul></li></ul></li></ul><p>Setup frameworks as static instead of dynamic.</p><p>Note: If the framework has Objective-C, there is an extra flag that needs to be set.</p><p>Note: From those first two WWDC talks, where the main focus is "pre-main" optimisation, there is a lot of focus on <strong>dyld</strong>. This is super low level, super difficult and specialised. Also, it applies mainly to Objective-C or C/C++ code. Good to know but probably it doesn't apply most of the "recent" times. Probably it applies more to libraries that are low level, things that talk with hardware, system libraries, etc.</p><p>Note: Don't remember the source (probably is the WWDC 16 video) but it seems the "before main" time should be, ideally, less than 400ms. [UPDATE] This is actually wrong. The correct is we need to "render first frame" in under 400ms.</p><h2>Post-Main</h2><p>Based on this <a href="https://developer.apple.com/videos/play/wwdc2019/423/">WWWD 19</a> video</p><p><strong>What is launch</strong></p><p>3 types of launch:</p><ul><li>Cold<ul><li>After reboot</li><li>Apps is not in memory</li><li>No process exists</li></ul></li></ul><ul><li>Warm<ul><li>Recently terminated</li><li>App is partially in memory</li><li>No process exists</li></ul></li></ul><ul><li>Resume<ul><li>App is suspended</li><li>App is fully in memory</li><li>Process exists</li></ul></li></ul><h3>Launch Process</h3><p>When user tap in the app icon and launch the app:</p><ul><li>(pre-main) iOS needs to do the necessary system-wide work. Let's think in around 100ms</li></ul><ul><li>(post-main) app's setup. The remaining 300ms tops. The app should be interactive and responsive at this point, even if with some placeholders.</li></ul><h3>Phases</h3><ul><li>System Interface</li><li>Runtime Init</li><li>UIKit Init</li><li>Application Init</li><li>Initial Frame Render</li><li>Extended</li></ul><h4>System Interface</h4><p><strong>DYLD3</strong> Dynamic Linker loads shared libraries and frameworks. It's now (iOS13) also available for everyone, not only system frameworks. This, basically, means the system is caching app's dependencies to warm launches. Even after an iOS update, the dependencies are processed in the background and cached. Not the dependencies themselves but the resolution of all dependencies (and their versions).</p><p><strong>Recommendations:</strong></p><ul><li>Avoid linking unused frameworks</li><li>Avoid dynamic library loading during launch (such as DLOpen or NSBundleLoad)</li><li>Hard link all your dependencies</li></ul><p>The second part is <strong>libSystem Init</strong>. Initialises the interface with low level system components. This should be faced as a fixed cost. There is nothing we can do.</p><h4>Runtime Init</h4><p>Static initializer. Here is where/when the system initialises the language (Objective-C or Swift) runtime. Also, it invokes all <strong>class static load methods</strong>.</p><p>Usually our app should not do any work here unless there is static initializers. The recommendations are to not have any initialisation here. From a previous WWDC video, it seems this only applies to Objective-C code. Basically, avoid using <code>+ [Class load];</code>. If necessary, use <code>+ [Class initialize];</code> because it's lazy.</p><h4>UIKit Init</h4><p>Here is where the System instantiate <code>UIApplication</code> and <code>UIApplicationDelegate</code>. Begins event processing and integration with the system.</p><p><strong>Recommendations:</strong></p><ul><li>Minimise work in <code>UIApplication</code> subclass</li><li>Minimise work in <code>UIApplicationDelegate</code> initialisation</li></ul><h4>Application Init</h4><p>Here is where the developer has the main impact.</p><p>Invokes <code>UIApplicationDelegate</code> app lifecycle callbacks:</p><ul><li>application:willFinishLaunchingWithOptions:</li><li>application:didFinishLaunchingWithOptions:</li></ul><ul><li>applicationDidBecomeActive:</li></ul><p>Note: Using UISceneDelegate changes the way the app is init. If using Scenes, the ViewControllers should be init in <code>scene:willConnectToSession:options:</code> and not in <code>application:didFinishLaunchingWithOptions:</code>.</p><p>Recommendation:</p><p>Defer any work that is not necessary for first frame. Lot it later or in the background.</p><h4>Initial Frame Render</h4><p><strong>First Frame Render</strong> -&gt; Creates, performs layout for and draws views:</p><pre><code>loadView
viewDidLoad
layoutSubviews
</code></pre><p><strong>Recommendations:</strong></p><ul><li>Flatten view hierarchies and lazily load views.</li><li>Optimise Auto-layout</li></ul><h4>Extended</h4><p>App-specific period after first frame. Not all the apps have this phase. Basically this is the lazy or asynchronous work triggered in previous phase.</p><p>This phase displays asynchronously loaded data. The app should be kept interactive and responsive.</p><p><strong>Note:</strong> Leverage <code>os_signpost</code> to measure work. More on <a href="https://developer.apple.com/videos/play/wwdc2018/405/">WWDC 18</a></p><h3>How to properly measure your launch</h3><p>The difficulty here is making sure we are comparing the same thing.</p><p>Remove variables such as <code>Networking</code> and <code>Background processes</code>. Might be less representative but give us consistent results to evaluate progress.</p><p><strong>Test in a Clean ans Consistent Environment</strong></p><ul><li>Reboot the device. Remove any unnecessary state. After every reboot, wait 2-3 minutes to system settle down.</li><li>Enable Airplaine mode or mock the network.</li><li>Use unchanging or no iCloud Account (in the device?!). Note: Probably if use Airplane mode this might not be a problem.</li><li>Use release build of the app</li><li>Measure warm launches. More consistent.</li></ul><p>Test with different data-sets to simulate different users.</p><p>Check this <a href="https://developer.apple.com/videos/play/wwdc2019/417/">WWDC 19</a> video for measurements</p><h3>Use Instruments to profile your launch</h3><p><strong>Tips and Tricks</strong></p><ul><li>Minimize<ul><li>Defer work unrelated to first frame</li><li>Move blocking work off main thread</li><li>Reduce memory usage</li><li>Prioritize</li><li>Identify the right QoS for the task</li><li>Utilize scheduler optimizations for app launch</li><li>Preserve the priority with the right primitives</li><li>Optimize</li><li>Simplify and limit existing work</li><li>Optimize algorithms and data structures</li><li>Cache resources and computations</li></ul></li></ul><h3>Track your launch over time</h3><h4>Resources:</h4><p>https://developer.apple.com/videos/play/wwdc2016/406/</p><p>https://developer.apple.com/videos/play/wwdc2017/413/</p><p>https://developer.apple.com/videos/play/wwdc2019/423/</p><p>https://developer.apple.com/videos/play/wwdc2018/405/</p><p>https://developer.apple.com/videos/play/wwdc2019/417/</p><p>https://developer.apple.com/library/archive/documentation/DeveloperTools/Conceptual/DynamicLibraries/100-Articles/DynamicLibraryDesignGuidelines.html</p><p>https://medium.com/globant/ios-app-launch-time-analysis-and-optimization-a219ee81447c</p>]]></content:encoded></item></channel></rss>