<?xml version="1.0" encoding="UTF-8"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content"><channel><title>Cabulas</title><description>I'm an iOS Software Engineer based in London</description><link>https://jjorgemoura.com</link><language>en</language><lastBuildDate>Wed, 9 Dec 2020 11:31:16 +0000</lastBuildDate><pubDate>Wed, 9 Dec 2020 11:31:16 +0000</pubDate><ttl>250</ttl><atom:link href="https://jjorgemoura.com/feed.rss" rel="self" type="application/rss+xml"/><item><guid isPermaLink="true">https://jjorgemoura.com/articles/environment</guid><title>How to Control the World</title><description>How to Control the World</description><link>https://jjorgemoura.com/articles/environment</link><pubDate>Fri, 20 Nov 2020 10:00:00 +0000</pubDate><content:encoded><![CDATA[<h1>How to Control the World</h1><h2>asdasdasd</h2><h2>Resources</h2><p><a href="https://www.pointfree.co/blog/posts/21-how-to-control-the-world">how-to-control-the-world</a></p>]]></content:encoded></item><item><guid isPermaLink="true">https://jjorgemoura.com/articles/swiftStuff</guid><title>What is and when to use Protocols with associated Types, Generics, Type Erasure and opaque Types</title><description>Protocol Oriented Programming</description><link>https://jjorgemoura.com/articles/swiftStuff</link><pubDate>Wed, 11 Nov 2020 08:00:00 +0000</pubDate><content:encoded><![CDATA[<h1>What is and when to use Protocols with associated Types, Generics, Type Erasure and opaque Types</h1><h2>Protocols</h2><p>Protocols are a simple concept. They define a contract, an interface for an entity. As Apple says, the <code>blueprint of methods, properties, and other requirements that suit a particular task or piece of functionality.</code></p><p>A protocol can be adopted by classes, structs and enums.</p><h3>Terminology</h3><p>Any type that satisfies the requirements of a protocol is said to <strong>conform</strong> to that protocol.</p><p>The protocol defines <strong>requirements</strong> that conforming types must implement.</p><h3>Protocol Extensions</h3><p>Protocols can be extended by <code>extensions</code>.</p><p>Extensions can be used to:</p><ul><li>implement some of the requirements</li><li>implement additional functionality that conforming types can take advantage of</li></ul><h3>Requirements</h3><p>The requirements can be:</p><ul><li>properties (instance or type)<ul><li>specify if is a <code>get</code> or a <code>get &amp; set</code></li><li>methods</li></ul></li></ul><p>Note: Properties need to be declared as <code>var</code>. Type properties are identified by the prefix <code>static</code>. However, the impementation entity can conform with it using <code>static</code> or <code>class</code> prefix.</p><p>Protocols can require specific instance methods and type methods to be implemented by conforming types.</p><p>Note: Default values can’t be specified for method parameters within a protocol’s definition.</p><h3>Mutating Method Requirements</h3><p>It’s sometimes necessary for a method to modify (or mutate) the instance it belongs to. For instance, methods on value types (structs and enums) a <code>mutating</code> keyword is needed before the method’s <code>func</code> keyword. This is to indicate that the method is allowed to modify the instance it belongs to and any properties of that instance.</p><p>Conforming value types also require the <code>mutating</code> keyword. Reference types don't.</p><h3>Initializer Requirements</h3><p>Protocols can also require specific initializers to be implemented by conforming types.</p><p>Note: <em>Class Implementations of Protocol Initializer Requirements</em></p><p>A protocol initializer requirement on a conforming <em>class</em> can be implemented as either a <em>designated</em> initializer or a <em>convenience</em> initializer. In both cases, the initializer implementation needs to be mark with the <code>required</code> modifier:</p><h3>Protocols as Types</h3><p>Protocols don’t actually implement any functionality themselves. Nonetheless, protocols can used as a fully fledged types in code. Using a protocol as a type is sometimes called an <strong>existential type</strong>, which comes from the phrase “<strong><em>there exists a type T such that T conforms to the protocol</em></strong>”.</p><p>Protocols can be used in many places where other types are allowed, including:</p><ul><li>As a parameter type or return type in a function, method, or initializer</li><li>As the type of a constant, variable, or property</li><li>As the type of items in an array, dictionary, or other container</li></ul><h3>Delegation</h3><p>This design pattern is implemented by defining a protocol that encapsulates the <em>delegated</em> responsibilities, such that a conforming type (known as a delegate) is guaranteed to provide the functionality that has been delegated.</p><p>Note: To prevent <em>strong reference cycles</em>, delegates are declared as <code>weak</code> references. Marking the protocol as <strong>class-only</strong> lets the entity that has the delegate to declare that its delegate must use a <code>weak</code> reference. A "class-only" protocol is marked by its inheritance from <code>AnyObject</code>.</p><h3>Adding Protocol Conformance with an Extension</h3><p>An existing type can be extended to adopt and conform to a new protocol, even if there is no access to the source code for the existing type. This is, for example, extending the type <code>String</code> to conform with a new protocol.</p><p>Extensions can add new properties, methods, and subscripts to an existing type, and are therefore able to add any requirements that a protocol may demand.</p><p>Note: Existing instances of a type automatically adopt and conform to a protocol when that conformance is added to the instance’s type in an extension.</p><h3>Conditionally Conforming to a Protocol</h3><p>A generic type may be able to satisfy the requirements of a protocol only under certain conditions, such as when the type’s generic parameter conforms to the protocol. A generic type can conditionally conform to a protocol by listing constraints when extending the type. Write these constraints after the name of the protocol you’re adopting by writing a generic where clause.</p><p>Example:</p><pre><code class="language-swift">extension Array: TextRepresentable where Element: TextRepresentable {
    var textualDescription: String {
</code></pre><h3>Synthetized protocols</h3><h4>Equatable</h4><p>Swift provides a synthesized implementation of Equatable for the following kinds of custom types:</p><ul><li>Structures that have only stored properties that conform to the Equatable protocol</li><li>Enumerations that have only associated types that conform to the Equatable protocol</li><li>Enumerations that have no associated types</li></ul><h4>Hashable</h4><p>Swift provides a synthesized implementation of Hashable for the following kinds of custom types:</p><ul><li>Structures that have only stored properties that conform to the Hashable protocol</li><li>Enumerations that have only associated types that conform to the Hashable protocol</li><li>Enumerations that have no associated types</li></ul><h4>Comparable</h4><p>Swift provides a synthesized implementation of Comparable for enumerations that don’t have a raw value. If the enumeration has associated types, they must all conform to the Comparable protocol. To receive a synthesized implementation of <, declare conformance to Comparable in the file that contains the original enumeration declaration, without implementing a < operator yourself. The Comparable protocol’s default implementation of <=, >, and >= provides the remaining comparison operators.

### Protocol Inheritance

A protocol can inherit one or more other protocols and can add further requirements on top of the requirements it inherits. The syntax for protocol inheritance is similar to the syntax for class inheritance, but with the option to list multiple inherited protocols, separated by commas.

### Protocol Composition

It can be useful to require a type to conform to multiple protocols at the same time. You can combine multiple protocols into a single requirement with a protocol composition. Protocol compositions behave as if you defined a temporary local protocol that has the combined requirements of all protocols in the composition. Protocol compositions don’t define any new protocol types.

Protocol compositions have the form `SomeProtocol & AnotherProtocol`. You can list as many protocols as you need, separating them with ampersands (**&**). In addition to its list of protocols, a protocol composition can also contain one class type, which you can use to specify a required superclass.

### Protocol Conformance

The operators `is` and `as` (Type Casting) can be used to check for protocol conformance, and to cast to a specific protocol. Checking for and casting to a protocol follows exactly the same syntax as checking for and casting to a type:

- The `is` operator returns true if an instance conforms to a protocol and returns false if it doesn’t.
- The `as?` version of the downcast operator returns an optional value of the protocol’s type, and this value is nil if the instance doesn’t conform to that protocol.
- The `as!` version of the downcast operator forces the downcast to the protocol type and triggers a runtime error if the downcast doesn’t succeed.

### Optional Protocol Requirements

Protocols support optional requirements. These requirements don’t have to be implemented by types that conform to the protocol. Optional requirements are prefixed by the `optional` modifier as part of the protocol’s definition.

Optional requirements are available to allow code that interoperates with Objective-C. Both the protocol and the optional requirement must be marked with the @objc attribute. Note that @objc protocols can be adopted only by classes that inherit from Objective-C classes or other @objc classes.

An important note is that optional requirements **can’t be adopted** by structures or enumerations.

When a method or property in an optional requirement is used, its type automatically becomes an optional.

An optional protocol requirement can be called with optional chaining, to account for the possibility that the requirement was not implemented by a type that conforms to the protocol.

### Protocol Extensions (2)

Protocols can be extended to provide method, initializer, subscript, and computed property implementations to conforming types. This allows defining behavior on protocols themselves, rather than in each type’s individual conformance or in a global function.

Note: Protocol extensions can add implementations to conforming types but can’t make a protocol extend or inherit from another protocol. Protocol inheritance is always specified in the protocol declaration itself.

#### Providing Default Implementations

Protocol extensions can be used to provide a default implementation to any method or computed property requirement of that protocol. If a conforming type provides its own implementation of a required method or property, that implementation will be used instead of the one provided by the extension.

Note: Protocol requirements with default implementations provided by extensions are distinct from optional protocol requirements. Although conforming types don’t have to provide their own implementation of either, requirements with default implementations can be called without optional chaining.

#### Adding Constraints to Protocol Extensions

It is possible to specify constraints that conforming types must satisfy before the methods and properties of the extension are available.

Example: `extension Collection where Element: Equatable {`

## Generics

The concept of generics is kind of simple.


## Protocols with Associated Types (PATs)




## Type Erasure

This is a technique to help hiding the type of a Protocol with an associated type.




## Opaque Types

Introduced in Swift 5.1.





## Resources

[Protocol-oriented Programming in Swift](https://www.youtube.com/watch?v=xE5EcHuz52I)
</p>]]></content:encoded></item><item><guid isPermaLink="true">https://jjorgemoura.com/articles/enums</guid><title>Enumerations</title><description>Enums</description><link>https://jjorgemoura.com/articles/enums</link><pubDate>Mon, 9 Nov 2020 18:00:00 +0000</pubDate><content:encoded><![CDATA[<h1>Enumerations</h1><p>When to use Enumerations</p><p>Swift <code>enums</code> could break the Open/Close principle. The alternative is to use <code>Structs</code> instead of <code>Enums</code>.</p><p>If something is changing constantly, then it should not be an enumeration. The reason is that adding a new case, or extending a programing, should not mean change existing code. Is this that means Open for extensability and Close for modification.</p><p>Open / Closed Priciple</p><h2>Resources</h2><p><a href="http://kostiakoval.github.io/posts/swift-enums-the-not-so-good-parts">Swift enums - the not so good parts</a></p>]]></content:encoded></item><item><guid isPermaLink="true">https://jjorgemoura.com/articles/protocolOriented</guid><title>Protocol Oriented Programming, the good, the bad and the ugly</title><description>Protocol Oriented Programming</description><link>https://jjorgemoura.com/articles/protocolOriented</link><pubDate>Mon, 9 Nov 2020 15:00:00 +0000</pubDate><content:encoded><![CDATA[<h1>Protocol Oriented Programming, the good, the bad and the ugly</h1><h2>The Good</h2><p>Types are first class citizens.</p><h2>The Bad</h2><p>The <code>Self</code> requirement. The type of <code>Self</code> is the type of the entity thsat conforms with the protocol.</p><p>One way to fix the <code>Self</code> requirement is to force entity to be homogeneous. This is achieved with generics and type constraint of the generic type.</p><h3>Two worlds of Protocols</h3><p>Without <code>Self</code> requirement</p><pre><code class="language-Swift">func precedes(other: Ordered) -&gt; Bool
</code></pre><p>Usable as a Type <code>func sort(inout a: [Ordered])</code></p><p>Think "heterogeneous"</p><p>Every model needs to deal with all others</p><p>Dynamic dispatch</p><p>Less optimizable</p><p>With <code>Self</code> requirement</p><pre><code class="language-Swift">func precedes(other: Self) -&gt; Bool
</code></pre><p>Only usable as a generic constraint <code>func sort&lt;T: Ordered&gt;(inout a: [T])</code></p><p>Think "homogeneous"</p><p>Models are free from interaction</p><p>Static dispatch</p><p>More optimizable</p><h2>The Ugly</h2><p>Having a downcast is a code smell.</p><pre><code class="language-swift">as! ASubclass
</code></pre><p>A sign that a type relationship was lost. Usually due to using classes for abstration.</p><h2>Other info</h2><p>Apple is also using <code>Structs</code> with <code>closures</code> instead of protocols (for a delegate).</p><h2>Resources</h2><p><a href="https://www.youtube.com/watch?v=xE5EcHuz52I">Protocol-oriented Programming in Swift</a></p><p><a href="https://www.swiftbysundell.com/podcast/71/">71: “Polymorphic interfaces”</a></p><p><a href="https://twitter.com/pointfreeco/status/1276547004882190342">https://twitter.com/pointfreeco/status/1276547004882190342</a></p>]]></content:encoded></item><item><guid isPermaLink="true">https://jjorgemoura.com/tips/logging</guid><title>Quick tips</title><description>Using logging #1</description><link>https://jjorgemoura.com/tips/logging</link><pubDate>Mon, 26 Oct 2020 11:45:00 +0000</pubDate><content:encoded><![CDATA[<h1>Quick tips</h1><p>How to start using OS.Logging consistently and frequenty instead of <code>print</code> and <code>NSLog</code>.</p><h2>Intro</h2><p>Apple has introduced two APIs to handle logging.</p><ul><li>OSLog (WWDC 2016)</li></ul><ul><li>Logging (WWDC 2020)</li></ul><p>The <code>Logging</code> API is a more refined API. Also, it handles String interpolation. Thus, we just dont't need to use string format specifiers to format the messages.</p><h2>Setup</h2><h3><code>OSLog</code></h3><p>After this, any call should be just (<code>OSLog</code> version)</p><p>A helper bit should be used for convenience:</p><pre><code class="language-swift">extension OSLog {

    private static let defaultSubsystem = Bundle.main.bundleIdentifier ?? "unknown"

    static let appLifecycle = OSLog(subsystem: defaultSubsystem, category: "appLifecycle")
    static let temp = OSLog(subsystem: defaultSubsystem, category: "debugMessages")
}

</code></pre><p>Then, any call is just:</p><pre><code class="language-swift">    os_log("APPDELEGATE -&gt; CONTINUE USER ACTIVITY || userActivity -&gt; %{public}@ || title -&gt; %{public}@", log: .temp, type: .debug, userActivity.activityType, userActivity.title ?? "---")
</code></pre><h3><code>Logging</code></h3><p>If using the new <code>Logging</code> API, it should be just:</p><pre><code class="language-swift">let logger = Logger(
        subsystem: "com.xpto.app",
        category: "FeedDownloader"
    )
</code></pre><p>or:</p><pre><code class="language-swift">static var subsystem = Bundle.main.bundleIdentifier!

static let viewCycle = Logger(subsystem: subsystem, category: "viewcycle")
</code></pre><p>Then, use the api should be just:</p><pre><code class="language-swift">    self.logger.info("Feed downloaded. Contents UUID is \(contents.uuid, privacy: .private(mask: .hash))")

    // or

    Logger.viewCycle.info("View did load!")
</code></pre><h2>Resources</h2><p><a href="https://www.avanderlee.com/workflow/oslog-unified-logging/">Swift Lee - OSLog and Unified logging as recommended by Apple</a></p><p><a href="https://wwdcbysundell.com/2020/meet-the-new-logger-api/">WWDC by Sundell - Meet the new Logger API</a></p><p><a href="https://developer.apple.com/library/archive/documentation/CoreFoundation/Conceptual/CFStrings/formatSpecifiers.html">Apple - String format specifiers</a></p>]]></content:encoded></item><item><guid isPermaLink="true">https://jjorgemoura.com/tips/debugging</guid><title>Some quick usefull tools and commands</title><description>Debug Tip #1</description><link>https://jjorgemoura.com/tips/debugging</link><pubDate>Mon, 26 Oct 2020 07:45:00 +0000</pubDate><content:encoded><![CDATA[<h1>Some quick usefull tools and commands</h1><h2>Read all the Registers</h2><p>This is a usefull command to print all the general purpose registers.</p><pre><code class="language-bash">(lldb) register read
</code></pre><p>However, a better way, via a launch argument, the Layout Feedback Loop Debugger</p><h2>Layout Feedback Loop Debugger</h2><pre><code class="language-bash">- UIViewLayoutFeedbackLoopDebuggingThreshold 100   // 50....1000
- NSViewLayoutFeedbackLoopDebuggingThreshold 100   // 50....1000
</code></pre><h2>Use the default Launch Arguments and Environment Variables</h2><p>We could use default Launch Arguments already provided by Xcode in Scheme editor.</p><p>Some exemples of Launch Arguments are:</p><ul><li>Localization Debugging</li></ul><ul><li>Application Language</li></ul><ul><li>Application Region</li></ul><p>Some exemples of Environment Variables are:</p><ul><li>Malloc Scribble</li></ul><h2>Import UIKit</h2><p>Type</p><pre><code class="language-bash">(lldb) expr @import UIKit
(lldb) po ((UIView *)0x3e34dd23).frame
</code></pre><h2>Inspect private properties without subclass</h2><p>Key Paths to the rescue</p><h2>Resources</h2><p><a href="https://www.youtube.com/watch?v=LbAlIzxSO6M">Carola Nitz - Advanced Debugging Techniques your senior hasn’t told you about</a></p><p><a href="https://developer.apple.com/videos/play/wwdc2016/236">WWDC - What's New in Auto Layout</a></p><p><a href="https://developer.apple.com/library/content/technotes/tn2239">iOS Debugging magic</a> <a href="https://developer.apple.com/library/content/technotes/tn2124">macOS Debugging magic</a></p>]]></content:encoded></item></channel></rss>