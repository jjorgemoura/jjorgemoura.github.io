<?xml version="1.0" encoding="UTF-8"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content"><channel><title>Cabulas</title><description>I'm an iOS Software Engineer based in London</description><link>https://jjorgemoura.com</link><language>en</language><lastBuildDate>Sat, 16 May 2020 09:57:35 +0000</lastBuildDate><pubDate>Sat, 16 May 2020 09:57:35 +0000</pubDate><ttl>250</ttl><atom:link href="https://jjorgemoura.com/feed.rss" rel="self" type="application/rss+xml"/><item><guid isPermaLink="true">https://jjorgemoura.com/manifestos/cicd</guid><title>The CI/CD Manifesto</title><description>The CI/CD Manifesto.</description><link>https://jjorgemoura.com/manifestos/cicd</link><pubDate>Sat, 16 May 2020 20:00:00 +0000</pubDate><content:encoded><![CDATA[<h1>The CI/CD Manifesto</h1><p>My first post's text.</p>]]></content:encoded></item><item><guid isPermaLink="true">https://jjorgemoura.com/articles/Closures</guid><title>Closures</title><description></description><link>https://jjorgemoura.com/articles/Closures</link><pubDate>Sat, 16 May 2020 09:56:20 +0000</pubDate><content:encoded><![CDATA[<h1>Closures</h1><p>Closures is a hot and difficult topic. So much to learn and understand. It is not an easy topic.</p><p>Let's start with this <a href="https://www.swiftbysundell.com/posts/capturing-objects-in-swift-closures">article</a> from Sundell, <strong>Capturing objects in Swift closures</strong>.</p><h2>Escaping / non-escaping</h2><p>There are two closures variants - escaping and non-escaping.</p><p>Escaping closures are simply closures that aren't run immediatly in the body of the method.</p><p><strong>no escaping</strong></p><pre><code>func applyMutliplication(value: Int, multFunction: Int -&gt; Int) -&gt; Int {
  return multFunction(value)
}
</code></pre><p><strong>escaping</strong></p><pre><code>//1
let actionHandlers: [String: () -&gt; Void]
func setAction(for element: String, action: @escapingString -&gt; String) {
 self.actionHandlers[element] = action
}

//2
var completionHandlers: [() -&gt; Void] = []
func someFunctionWithEscapingClosure(completionHandler: @escaping () -&gt; Void) {
    completionHandlers.append(completionHandler)
}
</code></pre><p>The escaping closures, because they capture context, can be source of some retain cycles. Thus, a technique to prevent this is so declare [weak self] when we set the closure.</p><p>For understand better arc, the best starting point is Apple's <a href="https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/AutomaticReferenceCounting.html">documentation</a>.</p><p>This <a href="https://oleb.net/blog/2016/10/optional-non-escaping-closures/">article</a> contain some useful tips about the escaping closures. Basically, it only apllies to function types.</p><h2>Autoclosures</h2><p>This is just a bit of syntax sugar.</p><p>&gt; An autoclosure is a closure that is automatically created to wrap an expression that’s being passed as an argument to a function. It doesn’t take any arguments, and when it’s called, it returns the value of the expression that’s wrapped inside of it. &gt;</p><p>This way we can omit braces around a function’s parameter.</p><pre><code>// customersInLine is ["Ewa", "Barry", "Daniella"]
func serve(customer customerProvider: @autoclosure () -&gt; String) {
    print("Now serving \(customerProvider())!")
}
serve(customer: customersInLine.remove(at: 0))
// Prints "Now serving Ewa!"
</code></pre><p><strong>Note (from Apple):</strong> &gt; Overusing autoclosures can make your code hard to understand. The context and function name should make it clear that evaluation is being deferred. &gt;</p><p><strong>Note:</strong> It seems autoclosures are limited to closures that accept no parameters and returns someting.</p><h2>Retain Cycles</h2><p>To avoid retain cycles we must use <code>weak</code> or <code>unowned</code> variables.</p><p>If we have two classes that are referencing each other via properties, where both of which are allowed to be nil, there is the potential to cause a strong reference cycle. This scenario is best resolved with a weak reference. Suitable for when the weak instance will live less than the other instance.</p><p>Example to use <code>weak</code>:</p><pre><code>class Person {
    let name: String
    init(name: String) { self.name = name }
    var apartment: Apartment?
    deinit { print("\(name) is being deinitialized") }
}
 
class Apartment {
    let unit: String
    init(unit: String) { self.unit = unit }
    weak var tenant: Person?
    deinit { print("Apartment \(unit) is being deinitialized") }
}
</code></pre><p>Note that both entities (Person and Apartment) can be <code>nil</code>.</p><p>If we have two classes that are referencing each other via properties, where one is allowed to be nil but not the other, there is the potential to cause a strong reference cycle. This scenario is best resolved with a unowned reference. Suitable for when the unowned instance will live the same or more than the other instance.</p><p>So, basically, <code>unowned</code> is the same as <code>weak</code> but because we think the variable will never be nill at the point we need to use it, then we can use <code>unowned</code> and, therefore, avoid the optional of the weak var.</p><pre><code>class Customer {
    let name: String
    var card: CreditCard?
    init(name: String) {
        self.name = name
    }
    deinit { print("\(name) is being deinitialized") }
}
 
class CreditCard {
    let number: UInt64
    unowned let customer: Customer
    init(number: UInt64, customer: Customer) {
        self.number = number
        self.customer = customer
    }
    deinit { print("Card #\(number) is being deinitialized") }
}
</code></pre><p>The variable <code>Customer</code> is unowned because won't be nil.</p><p>Important note: &gt; Use an unowned reference only when you are sure that the reference always refers to an instance that has not been deallocated. &gt; If you try to access the value of an unowned reference after that instance has been deallocated, you’ll get a runtime error. &gt;</p><p>There is a third scenario. Is where both properties shouldn't be nil. This scenario is best resolved with a unowned reference for one property and a weak reference for the other property.</p><h2>Retain Cycles for Closures</h2><p>Now it's a bit more dificult to understand.</p><p>From Apple's, <em>Define a capture in a closure as an unowned reference when the closure and the instance it captures will always refer to each other, and will always be deallocated at the same time. Conversely, define a capture as a weak reference when the captured reference may become nil at some point in the future</em>.</p><p>in order to fix the Strong Reference Cycles in closures, we need to define a capture list as part of the closure’s definition.</p><p>From <a href="https://www.swiftbysundell.com/posts/capturing-objects-in-swift-closures">here</a>, let's have a look on an example that causes a retain cycle in a closure.</p><pre><code>class ListViewController: UITableViewController {
    private let viewModel: ListViewModel

    init(viewModel: ListViewModel) {
        self.viewModel = viewModel

        super.init(nibName: nil, bundle: nil)

        viewModel.observeNumberOfItemsChanged {
            // This will cause a retain cycle, since our view controller
            // retains its view model, which in turn retains the view
            // controller by capturing it in an escaping closure.
            self.tableView.reloadData()
        }
    }
}
</code></pre><p>We can think of <code>viewModel.</code> to know and to keep a reference to the <code>viewController</code> instance, with both not being optionals.</p><p>One way to fix this retain cycle is to capture self as weak (<code>viewModel.observeNumberOfItemsChanged { [weak self] in</code>)</p><p>Every time we set a weak variable, that variable will be optional. So, when using that varable we can use it as:</p><ul><li>an optional (?)</li></ul><ul><li>optional binding (<code>if let</code> or <code>guard let</code>)</li></ul><p><strong>Some resources:</strong></p><p><a href="https://www.swiftbysundell.com/posts/capturing-objects-in-swift-closures">https://www.swiftbysundell.com/posts/capturing-objects-in-swift-closures</a></p><p><a href="https://krakendev.io/blog/weak-and-unowned-references-in-swift">https://krakendev.io/blog/weak-and-unowned-references-in-swift</a></p><p><a href="https://www.uraimo.com/2016/10/27/unowned-or-weak-lifetime-and-performance/">https://www.uraimo.com/2016/10/27/unowned-or-weak-lifetime-and-performance/</a></p><p><a href="https://stackoverflow.com/questions/24320347/shall-we-always-use-unowned-self-inside-closure-in-swift/34542424">https://stackoverflow.com/questions/24320347/shall-we-always-use-unowned-self-inside-closure-in-swift/34542424</a></p><p><a href="https://stackoverflow.com/questions/24011575/what-is-the-difference-between-a-weak-reference-and-an-unowned-reference/26025176#26025176">https://stackoverflow.com/questions/24011575/what-is-the-difference-between-a-weak-reference-and-an-unowned-reference/26025176#26025176</a></p><p><a href="https://blog.haloneuro.com/swift-memory-leak-gotcha-with-weak-self-67293d5bc060">https://blog.haloneuro.com/swift-memory-leak-gotcha-with-weak-self-67293d5bc060</a></p><p><a href="https://medium.com/@streem/understanding-memory-leaks-in-closures-48207214cba">https://medium.com/@streem/understanding-memory-leaks-in-closures-48207214cba</a></p><p><a href="https://oleb.net/blog/2016/10/optional-non-escaping-closures/">https://oleb.net/blog/2016/10/optional-non-escaping-closures/</a></p>]]></content:encoded></item><item><guid isPermaLink="true">https://jjorgemoura.com/articles/DependencyInjection</guid><title>DI - Dependency Injection</title><description></description><link>https://jjorgemoura.com/articles/DependencyInjection</link><pubDate>Sat, 16 May 2020 09:56:20 +0000</pubDate><content:encoded><![CDATA[<h1>DI - Dependency Injection</h1><p>From SOLID, the D stand for Dependency Inversion principle. In order to handle this, the technique to follow is doing Dependency Injection.</p><p>Also, DI is a good technique to avoid the use of Singletons everywhere.</p><p>In order to accomplish DI, we need/must use protocols (POP).</p><p>In order to accomplish DI, we have 4 options:</p><ul><li>via init</li></ul><p>All the dependencies are set during the initialisation. In order to avoid having multiple parameters, we can use Swift capabilities of setting default values for the parameters. This capability allow to use the default values in production code but pass fake objects during tests.</p><ul><li>via properties</li></ul><p>Quite similar with the previous technique. However this force the parameters to be optional (ok, we can set default values and only set new values for testing) or we need to set all the dependencies after the init. This technique is used almost always when we are dealing with ViewControllers. This due to the fact ViewControllers initialisers works.</p><ul><li>via method parameters</li></ul><p>This is, in my opinion, a less suitable option.</p><ul><li>via a Lib</li></ul><p>Personally I don't like this option. There is a kind of black magic behind that I don't appreciate.</p><p><strong>Tools</strong></p><p><a href="https://github.com/Swinject/Swinject">Swinject</a></p><p><strong>Resources</strong></p><p><a href="https://www.swiftbysundell.com/posts/different-flavors-of-dependency-injection-in-swift">https://www.swiftbysundell.com/posts/different-flavors-of-dependency-injection-in-swift</a></p><p><a href="https://www.swiftbysundell.com/posts/dependency-injection-using-factories-in-swift">https://www.swiftbysundell.com/posts/dependency-injection-using-factories-in-swift</a></p><p><a href="https://artsy.github.io/blog/2016/06/27/dependency-injection-in-swift/">https://artsy.github.io/blog/2016/06/27/dependency-injection-in-swift/</a></p><p><a href="https://www.objc.io/issues/15-testing/dependency-injection/">https://www.objc.io/issues/15-testing/dependency-injection/</a></p><p><a href="https://cocoacasts.com/nuts-and-bolts-of-dependency-injection-in-swift/">https://cocoacasts.com/nuts-and-bolts-of-dependency-injection-in-swift/</a></p><p><a href="https://codeburst.io/solid-design-principle-using-swift-fa67443672b8">https://codeburst.io/solid-design-principle-using-swift-fa67443672b8</a></p><p><a href="https://en.wikipedia.org/wiki/Dependency_inversion_principle">https://en.wikipedia.org/wiki/Dependency<em>inversion</em>principle</a></p>]]></content:encoded></item><item><guid isPermaLink="true">https://jjorgemoura.com/articles/GCD</guid><title>Multi Threading</title><description></description><link>https://jjorgemoura.com/articles/GCD</link><pubDate>Sat, 16 May 2020 09:56:20 +0000</pubDate><content:encoded><![CDATA[<h1>Multi Threading</h1><p>There is multiple APIs available that allow us to write multi-threading software.</p><p>Some of those available API for iOS are:</p><ul><li>Threads</li><li>Grand Central Dispatch (GCD)</li><li>NSOperationQueue</li><li>Run Loops</li></ul><p>Threads are subunits of processes. Operating system scheduler can schedule threads independently. Threads are, generally, the base of all concurrency APIs. &gt; Multiple threads can be executed at the same time on a single CPU core (or at least perceived as at the same time). The operating system assigns small slices of computing time to each thread, so that it seems to the user as if multiple tasks are executed at the same time. If multiple CPU cores are available, then multiple threads can be executed truly in parallel, therefore lessening the total time needed for a certain workload. &gt;</p><p>It's an OS scheduler's responsibility the management of the execution of the threads.</p><p>On iOS, the NSThread API is a simple Objective-C wrapper around pthreads. This API is a quite low level API when compared with GCD or NSOperationQueues.</p><p>Operation queues are a Cocoa abstraction of the queue model exposed by GCD. The main advantage of NSOperationQueues API over GCD is that the API is more well defined (more Objective-C like) and that the user can have more control over the execution of the queue, in particular, can cancel scheduled tasks.</p><p>Let's focus on <a href="https://developer.apple.com/documentation/dispatch">GCD</a>.</p><h2>Grand Central Dispatch</h2><p>GCD is based on the concept of queues, not threads. It's GCD's responsibility to transform the management of the queues in threads.</p><p>GCD decides on which particular thread the blocks of code are going to be executed on. Thus, is GCD's responsibility to manage how many threads are being created.</p><p>&gt; GCD exposes five different queues: the main queue running on the main thread, three background queues with different priorities, and one background queue with an even lower priority, which is I/O throttled. &gt;</p><p>There is a change in GCD API from Objective-C to Swift.</p><p>In Objective-C, the API looks more like C functions where, in Swift, the API looks more a native Swift API. The main class is <code>DispatchQueue</code>.</p><p><strong>Serial and Concurrent Queues</strong></p><p>A dispatch queue can be either serial or concurrent (parallel). On serial queues, the work items are executed one at a time. On concurrent queues, work items are dequeued (start to be executed) in order, but run all at once (at same time) and can finish in any order.</p><p>Both serial and concurrent queues process work items in first in, first-out (FIFO) order. Basically, they start to be executed/processed by scheduled order. It's the OS which determines how many concurrent jobs start to be executed.</p><p><strong>System-Provided Queues</strong></p><p>When an app launches, the system automatically creates a special queue called the main queue. Work items enqueued to the main queue execute serially on app’s main thread.</p><p>The system also creates a number of global concurrent dispatch queues. We can access the global concurrent queue that best matches a specified quality of service (QoS) using the global(attributes:) type method.</p><p><strong>Note (from Apple's docs):</strong> &gt; Attempting to synchronously execute a work item on the main queue results in dead-lock.&gt;</p><p><strong>QoS</strong></p><ul><li>userInteractive -&gt; The user-interactive quality of service class.</li><li>userInitiated -&gt; The user-initiated quality of service class.</li><li>default -&gt; The default quality of service class.</li><li>utility -&gt; The utility quality of service class.</li><li>background -&gt; The background quality of service class</li><li>unspecified -&gt; The absence of a quality of service class.</li></ul><p><strong>Some thoughts</strong></p><p>My idea is to keep it simple. This subject is already complex enough to keep adding even more complexity in managing multiple queues, with multiple QoS, of different kind (serial vs concurrent) and even adding some custom queues.</p><p><strong>Strategy</strong></p><p>Main queue -&gt; Only async -&gt; For UI related work</p><p>System queue (concurrent) -&gt; qos = default -&gt; network and other secondary work</p><p>System queue (concurrent) -&gt; qos = background -&gt; background work (when the app is not active)</p><p>Custom queue (serial) -&gt; qos = utility -&gt; some serial process (for example, apply a filter to an array of images)</p><h2>Thread Safety / Locks</h2><p>There are several uses of locks/synchonize.</p><p>Objective-C has a <code>@synchronized</code>. It seems that, no with Swift, are are some tricks to keep still be using this feature, in particular through their low level function <code>objc_sync_enter</code>.</p><p>However, using this should be avoided.</p><p>If we want to guarantee thread safety on, for example, setting a property, we should use DispatchQueue instead.</p><p>Check this <a href="http://basememara.com/creating-thread-safe-arrays-in-swift/">article</a> and <a href="https://medium.com/@oyalhi/dispatch-barriers-in-swift-3-6c4a295215d6">this</a> one.</p><p>Basically the strategy is use a queue to control the access to a specific variable, the one we want to guarantee to be thread safe.</p><p>If using a <code>Serial Queue</code>, we make the read operation <code>sync</code> in order to getters receive the value immediately (even though it could take a while to the job ton be processed thus this getter could block the calling thread). The setters should be <code>async</code>.</p><p>This way, because the queue is serial, all the requests (getter and setter) are executed one-by-one, in a FIFO queue, and only the getters are eventually delayed if the queue is really busy.</p><pre><code>private let serialQueue = DispatchQueue(label: “serialQueue”)
private var dictionary: [String: Any] = [:]

public func set(_ value: Any, forKey key: String) {
    serialQueue.sync {
        dictionary[key] = value
    }
}

public func object(forKey key: String) -&gt; Any? {
    var result: Any?
       
    serialQueue.sync {
        result = dictionary[key]
    }
    // returns after serialQueue is finished operation
    // because serialQueue is run synchronously
    return result
}
</code></pre><p>Alternative, we can use a <code>Concurrent Queue</code>.</p><pre><code>private let concurrentQueue = DispatchQueue(label: "concurrentQueue", attributes: .concurrent)
private var dictionary: [String: Any] = [:]
    
public func set(_ value: Any?, forKey key: String) {
    // .barrier flag ensures that within the queue all reading is done
    // before the below writing is performed and
    // pending readings start after below writing is performed
    concurrentQueue.async(flags: .barrier) {
        self.dictionary[key] = value
    }
}

public func object(forKey key: String) -&gt; Any? {
    var result: Any?

    concurrentQueue.sync {
        result = dictionary[key]
    }

    // returns after concurrentQueue is finished operation
    // because concurrentQueue is run synchronously
    return result
}
</code></pre><p>The difference is we can have multiple tasks running at same time. For getters that behaviour is desired. However, for getters, we don't want that. So the trick is to set a <code>barrier</code>. This flag makes the setter to behave a if it was a serial queue. Basically, it only starts when everything already queued finishes and nothing starts before this specific job is done. The <code>barrier</code> attribute is <code>flag</code> in a <code>DispatchWorkItem</code> and these flags are only valid for that specific item. It's kind of a temporary attribute of permission.</p><h3>Articles</h3><p><a href="https://www.objc.io/issues/2-concurrency/concurrency-apis-and-pitfalls/#grand-central-dispatch">https://www.objc.io/issues/2-concurrency/concurrency-apis-and-pitfalls/#grand-central-dispatch</a></p><p><a href="https://developer.apple.com/documentation/dispatch">https://developer.apple.com/documentation/dispatch</a></p><p><a href="https://www.raywenderlich.com/148513/grand-central-dispatch-tutorial-swift-3-part-1">https://www.raywenderlich.com/148513/grand-central-dispatch-tutorial-swift-3-part-1</a></p><p><a href="https://www.bobthedeveloper.io/blog/intro-to-grand-central-dispatch-in-swift-with-bob">https://www.bobthedeveloper.io/blog/intro-to-grand-central-dispatch-in-swift-with-bob</a></p><p><a href="http://basememara.com/creating-thread-safe-arrays-in-swift/">http://basememara.com/creating-thread-safe-arrays-in-swift/</a></p><p><a href="https://rhonabwy.com/2017/03/14/__trashed/">https://rhonabwy.com/2017/03/14/__trashed/</a></p><p><a href="https://medium.com/@oyalhi/dispatch-barriers-in-swift-3-6c4a295215d6">https://medium.com/@oyalhi/dispatch-barriers-in-swift-3-6c4a295215d6</a></p>]]></content:encoded></item><item><guid isPermaLink="true">https://jjorgemoura.com/articles/InheritanceComposition</guid><title>Swift Inheritance vs Composition</title><description></description><link>https://jjorgemoura.com/articles/InheritanceComposition</link><pubDate>Sat, 16 May 2020 09:56:20 +0000</pubDate><content:encoded><![CDATA[<h1>Swift Inheritance vs Composition</h1><p>Swift features and current best practices favor the use of composition over inheritance.</p><p>A current trend on development with swift is Protocol-Oriented Programming.</p><h3>Inheritance</h3><p>Inheritance is one of the fundamental characteristic of <strong><em>object-oriented programming</em></strong>.</p><p><strong>Pros</strong></p><ul><li>Subclasses doesn't need to implement all Base methods.</li></ul><p><strong>Cons</strong></p><ul><li>Fragile Base class(es)</li><li>Lack of flexibility</li><li>Dependencies (of all types and subtypes)</li></ul><h3>Composition</h3><p><strong>Pros</strong></p><ul><li>Less dependencies</li><li>Better in expressing <code>has-a</code></li></ul><p><strong>Cons</strong></p><ul><li>All classes need to implement all the methods specified in the protocol. With swift this can be avoided with the use of protocol extensions. Protocol extensions can provide a default implementation of a protocol on the protocol itself, rather than within an individual type's implementation<ul></ul></li></ul><h3>Some notes</h3><p>In the GoF's Design Pattern book we can find this quote:</p><p>&gt; Program to an interface, not an implementation.” “Favor ‘object composition’ over ‘class inheritance’.” &gt;</p><p>From wikipedia/Head First Design Patterns: &gt; Composition also provides a more stable business domain in the long term as it is less prone to the quirks of the family members. In other words, it is better to compose what an object can do (HAS-A) than extend what it is (IS-A).[1] &gt;</p><h3>Resources</h3><p><a href="https://en.wikipedia.org/wiki/Composition_over_inheritance">https://en.wikipedia.org/wiki/Composition<em>over</em>inheritance</a></p><p><a href="https://medium.com/ios-os-x-development/protocol-oriented-programming-in-swift-daba92bc9c98">https://medium.com/ios-os-x-development/protocol-oriented-programming-in-swift-daba92bc9c98</a></p><p><a href="http://mikebuss.com/2016/01/10/interfaces-vs-inheritance/">http://mikebuss.com/2016/01/10/interfaces-vs-inheritance/</a></p><p><a href="https://www.thoughtworks.com/insights/blog/composition-vs-inheritance-how-choose">https://www.thoughtworks.com/insights/blog/composition-vs-inheritance-how-choose</a></p>]]></content:encoded></item><item><guid isPermaLink="true">https://jjorgemoura.com/articles/Testing</guid><title>Tests Best Practices</title><description></description><link>https://jjorgemoura.com/articles/Testing</link><pubDate>Sat, 16 May 2020 09:56:20 +0000</pubDate><content:encoded><![CDATA[<h1>Tests Best Practices</h1><p>There are several types of tests. Let's have a better look of some of them:</p><ul><li>Unit Tests</li><li>Snapshot Tests</li><li>UI Tests</li></ul><h3>Unit Tests</h3><p>The simplest type of tests. Tests a unit of code. I would say it tests each public method of a class.</p><p>Could need to use expectations to tests asynchronous code.</p><p>All the network calls must be mocked.</p><h3>Snapshot Tests</h3><p>Very similar to unit tests but to test UIViews/UIViewControllers.</p><p>All data should be mocked.</p><h3>UI Tests</h3><p>In other to make all the UI Tests more robust and independent, it better to mock all the network calls.</p><p>The problem with UI Testing is with the way Apple has set it up. We got the app running in a process and the tests in another. The communication is done through the accessibility capabilities built into UIKit. That means we can not inject mocks or stub networks calls the way we usually do with unit tests.</p><p>It seems there are two options. They are:</p><ul><li>Add test resources into main app and control it via environment variable</li><li>Run a server locally</li></ul><p>The first option is not good at all. We need to ship, in the main target, all the data to handle the test mocks (json, etc) for the UI tests and using an environment variable to indicate if we are running tests or not.</p><p>The second option is much better however requires some extra setup. One of the best know servers is WireMock. There are some opinions saying we can also write our own server using Vapor. The advantage is having all control and using Swift all over the place, client side as well as in server side. Better check my other <a href="https://gist.github.com/jjorgemoura/c89a67b204b303232c41f4b6f2b0a516">gists</a>.</p><h3>Others</h3><p>It seems nowadays the integration tests have lost some importance. The main problem with them is that they became quite fragile due to the dependency of an external system, not only in terms of quality of data as well as in terms of availability.</p><h4>Resources</h4><p><a href="https://medium.com/@Tovkal/mocking-network-calls-while-ui-testing-61e8a4a07f81">https://medium.com/@Tovkal/mocking-network-calls-while-ui-testing-61e8a4a07f81</a></p><p><a href="https://gist.github.com/jjorgemoura/c89a67b204b303232c41f4b6f2b0a516">WireMock vs OHHTTPStubs</a></p>]]></content:encoded></item><item><guid isPermaLink="true">https://jjorgemoura.com/tips/APIKeys</guid><title>Securing API Keys and Secrets</title><description></description><link>https://jjorgemoura.com/tips/APIKeys</link><pubDate>Sat, 16 May 2020 09:56:20 +0000</pubDate><content:encoded><![CDATA[<h1>Securing API Keys and Secrets</h1><p>When using 3rd party services, traditionally we need to register our app in 3rd party service and get an API App ID (the app identifier) and also, most of the times, an App Secret (the app login key).</p><p>Usually the App ID is public (or can be treated as public) and can be stored in the app. In terms of security, should not be such big deal if someone access the App ID.</p><p>In terms of App Secret, here we should proceed with maximum careful. We should not store the secret in the code. It will became accessible to anyone through a reverse engineering process.</p><p>The best practice is to store the secret in our server and communicate with our server to retrieve any token (the secret or a token generated with the secret) our integrate with the 3rd party service always through our server-side.</p><p>Of course some services could require the secret only for some actions (write, access sensitive info, etc) and allow the user/app to access some endpoints only with the App ID.</p><p>Note that if someone access our App secret, the attack would only be in app authorisation and access and not the users credentials.</p><p>Online Resources:</p><p><a href="https://developers.facebook.com/docs/facebook-login/security">https://developers.facebook.com/docs/facebook-login/security</a></p><p><a href="https://developer.spotify.com/web-api/authorization-guide/">https://developer.spotify.com/web-api/authorization-guide/</a></p><p><a href="https://steelkiwi.com/blog/how-connect-spotify-sdk-your-project/">https://steelkiwi.com/blog/how-connect-spotify-sdk-your-project/</a></p><p><a href="https://github.com/spotify/ios-sdk/issues/877">https://github.com/spotify/ios-sdk/issues/877</a></p><p><a href="https://github.com/spotify/ios-sdk/issues/159">https://github.com/spotify/ios-sdk/issues/159</a></p><p><a href="https://aaronparecki.com/oauth-2-simplified/">https://aaronparecki.com/oauth-2-simplified/</a></p><p><a href="https://stormpath.com/blog/the-ultimate-guide-to-mobile-api-security">https://stormpath.com/blog/the-ultimate-guide-to-mobile-api-security</a></p><p><a href="https://hackernoon.com/mobile-api-security-techniques-682a5da4fe10">https://hackernoon.com/mobile-api-security-techniques-682a5da4fe10</a></p><p><a href="https://security.stackexchange.com/questions/19989/facebook-api-app-secret-possible-misuse">https://security.stackexchange.com/questions/19989/facebook-api-app-secret-possible-misuse</a></p><p><a href="https://arstechnica.com/information-technology/2010/09/twitter-a-case-study-on-how-to-do-oauth-wrong/">https://arstechnica.com/information-technology/2010/09/twitter-a-case-study-on-how-to-do-oauth-wrong/</a></p><p><a href="https://medium.com/ios-os-x-development/keeping-secrets-out-of-git-in-your-ios-app-c01a357e824b">https://medium.com/ios-os-x-development/keeping-secrets-out-of-git-in-your-ios-app-c01a357e824b</a></p>]]></content:encoded></item><item><guid isPermaLink="true">https://jjorgemoura.com/tips/AppleDevNaming</guid><title>Swift Standard Library / Foundations / Cocoa Touch / UIKit</title><description></description><link>https://jjorgemoura.com/tips/AppleDevNaming</link><pubDate>Sat, 16 May 2020 09:56:20 +0000</pubDate><content:encoded><![CDATA[<h1>Swift Standard Library / Foundations / Cocoa Touch / UIKit</h1><h2>UIKit</h2><p>Everything that starts with UI. Some classes are:</p><ul><li>UIViewController</li><li>UIButton</li><li>UIView</li></ul><p>etc.</p><p>UIKit imports Foundation so if we import UIKit, we don't need to import Foundation.</p><h2>CocoaTouch</h2><p>CocoaTouch contains UIKit with other basic frameworks, such as:</p><ul><li>UIKit</li><li>Foundation</li><li>CoreData</li><li>App Extensions</li><li>Multitasking</li><li>Notifications (local, push)</li><li>Map Kit</li><li>AddressBook Kit</li><li>etc.</li></ul><h2>Foundation</h2><p>Foundation is implemented in Objective-C. Is where primarily Objective-C defined their objects. It is kind of a <code>Objective-C Standard Library</code>, the Objective-C bits on top of C.</p><p>Is where is defined classes such as:</p><ul><li>NSNumber</li><li>NSString</li><li>NSArray</li><li>NSDictionary</li><li>NSDate</li><li>etc.</li></ul><p>In Swift we only need to import Foundation if we are interacting with Objective-C.</p><h2>Swift Standard Library</h2><p>Is where some base classes are defined, such as:</p><ul><li>Int</li><li>Double</li><li>Array</li><li>Dictionary</li><li>print() function</li><li>Some protocols (Collection, Equatable)</li><li>etc.</li></ul><p>It basically replaces Foundation.</p><h3>Resources</h3><ul><li><a href="https://developer.apple.com/documentation/swift">https://developer.apple.com/documentation/swift</a></li></ul>]]></content:encoded></item><item><guid isPermaLink="true">https://jjorgemoura.com/tips/BackgroundMode</guid><title>iOS Background Mode</title><description></description><link>https://jjorgemoura.com/tips/BackgroundMode</link><pubDate>Sat, 16 May 2020 09:56:20 +0000</pubDate><content:encoded><![CDATA[<h1>iOS Background Mode</h1><p>iOS supports background modes. Inside this capability we can even specify (enable/disable) a more precise mode.</p><p>Some of those modes are:</p><ul><li>Location Updates</li><li>Background Fetch</li><li>Remote Notifications</li></ul><p>In order to have this modes to work properly, we must implement an appDelegate method, <code>application(_:performFetchWithCompletionHandler:)</code></p><p>One important piece is setting the fetch refresh internal, calling <code>setMinimumBackgroundFetchInterval</code>.</p><p>For more information, it's better to check Apples Documentation.</p>]]></content:encoded></item><item><guid isPermaLink="true">https://jjorgemoura.com/tips/BuildOptimization</guid><title>Build Optimization</title><description></description><link>https://jjorgemoura.com/tips/BuildOptimization</link><pubDate>Sat, 16 May 2020 09:56:20 +0000</pubDate><content:encoded><![CDATA[<h1>Build Optimization</h1><p>Since the launch of Swift, several performance and quality issues has stuck Xcode. Those are mainly:</p><ul><li>build/compilation time</li><li>code completion</li><li>syntax highlight</li><li>debug variable inspect</li></ul><h4>How to improve Build / Compilation times (configuration)</h4><p>Let's start with Swift. It is well know some performance issues with Swift.</p><p><a href="https://medium.com/@RobertGummesson/regarding-swift-build-time-optimizations-fc92cdd91e31">Several</a> articles point out how <strong>Ternary</strong> or <strong>Nil Coalescing Operators</strong>, <strong>String concatination</strong>, among others, hurt build times.</p><p>Now, how about Xcode build paramaters?</p><p>For Swift, the starting point must be the <a href="https://swift.org/blog/whole-module-optimizations/">Whole Module Optimization</a> setting.</p><p>However, we need to be careful. The Whole Module Optimization is a good build setting because it groups all the code in one file and only after compiles everything, knowing so all the deep details of the code and therefore be able to optimize all the code. However, that means if we only change a line in class and tap build again it will build everything instead of just perform a incremental build.</p><p>Problem is with WMO, debug will not work properly after. For debug we need to set the optimization level as none.</p><p>In resume:</p><ul><li>set: <em>Optimization Level</em> as <code>Whole Module Optimization</code> for debug+release (in Swift Compiler) and set <em>Other Swift Flags</em> as <code>-Onone</code> for Debug only.</li></ul><p><strong>NOTE:</strong> For Swift code, we need to set the none flag diferently. We need to set the setting <code>Other Swift Flags</code> as <code>-Onone</code>.</p><ul><li>set: <em>Build Active Architecture Only</em> as <code>YES</code> for debug only.</li></ul><p><strong>Measure build time</strong></p><p><a href="https://www.jessesquires.com/blog/measuring-compile-times-xcode9/">This</a> is a really useful trick to help you measuring the compilation time by file.</p><p><strong>Debug symbols</strong></p><p>In this <a href="https://hackernoon.com/speed-up-swift-compile-time-6f62d86f85e6">article</a> the author claims we should set for Xcode to generate the dSYM file for the <code>debug</code> configuration. It seems Xcode, when create a new project, also set this setting that way.</p><h4>code completion + syntax highlight</h4><p>Here there isn't much we can do. The problem is with SourceKit. One good thing is to avoid having weird code (Libraries) in order that the code parse (through SourceKit) and compilation doesn't crash.</p><h4>Debug variable inspect</h4><p>One big problem is related with libraries/frameworks and how to debug (e.g., inspect variables) from inside the those libraries/frameworks.</p><p>This could be influenced by Carthage and the way we set the 3rd party Libraries.</p><h4>Xcode lag</h4><p><a href="https://twitter.com/kharrison/status/927506735258112000">Tip</a> from Apple?</p><h4>Extra Resources:</h4><p><a href="https://github.com/fastred/Optimizing-Swift-Build-Times">https://github.com/fastred/Optimizing-Swift-Build-Times</a></p><p><a href="https://useyourloaf.com/blog/swift-whole-module-optimization/">https://useyourloaf.com/blog/swift-whole-module-optimization/</a></p><p><a href="https://jobs.zalando.com/tech/blog/improving-swift-compilation-times-from-12-to-2-minutes/?gh_src=4n3gxh1">https://jobs.zalando.com/tech/blog/improving-swift-compilation-times-from-12-to-2-minutes/?gh_src=4n3gxh1</a></p><p><a href="http://developear.com/blog/2016/12/30/Speed-Swift-Compilation.html">http://developear.com/blog/2016/12/30/Speed-Swift-Compilation.html</a></p><p><a href="http://roadfiresoftware.com/2017/01/improving-swift-compile-times/">http://roadfiresoftware.com/2017/01/improving-swift-compile-times/</a></p><p><a href="http://roadfiresoftware.com/2016/10/cut-your-swift-build-times-in-half-with-this-one-weird-trick/">http://roadfiresoftware.com/2016/10/cut-your-swift-build-times-in-half-with-this-one-weird-trick/</a></p><p><a href="https://jobs.zalando.com/tech/blog/improving-swift-compilation-times-from-12-to-2-minutes/">https://jobs.zalando.com/tech/blog/improving-swift-compilation-times-from-12-to-2-minutes/</a></p><p><a href="https://hackernoon.com/speed-up-swift-compile-time-6f62d86f85e6">https://hackernoon.com/speed-up-swift-compile-time-6f62d86f85e6</a></p><p><a href="https://www.jessesquires.com/blog/measuring-compile-times-xcode9/">https://www.jessesquires.com/blog/measuring-compile-times-xcode9/</a></p>]]></content:encoded></item><item><guid isPermaLink="true">https://jjorgemoura.com/tips/BuildSettings</guid><title>Build Settings</title><description></description><link>https://jjorgemoura.com/tips/BuildSettings</link><pubDate>Sat, 16 May 2020 09:56:20 +0000</pubDate><content:encoded><![CDATA[<h1>Build Settings</h1><p>All the apps contains one <code>info.plist</code>. We can change the main plist to have another name. In the BuildSettings we can specify the path to the <code>info.plist</code>.</p><p>We can have plist as a child of others plist. This could be useful in order to avoid having huge plists.</p><p>We can also set <code>xcconfig</code> files to help setting some build settings vars. Things such as teamIDs or provisioning profiles are good candidates.</p><p>In order to access some variables defined in <code>xcconfig</code> inside the plist we can access then as <code>$(VAR_NAME)</code>.</p><p>All the <code>xcconfig</code> variables are immediatly visible inside the Build Settings panel, on the bottom, under the <code>User-Defined</code> section.</p><p>Right now, the main problem is how to access the <code>xcconfig</code> vars directly from code!</p><p><strong>Note:</strong></p><p>Some examples uses the <code>OTHER SWIFT FLAGS</code> to specify settings that can be accessible from inside the code. However, like the name indicates, only works for booleans (a flag).</p><p><strong>Note:</strong></p><p>It seems <code>PREPROCESSOR MACROS</code> only works for Objective-C code. So far, I wans't able to figure out how to define string macros, only boolean.</p><p><strong>Resources</strong></p><p><a href="http://szulctomasz.com/2015/11/14/xcode-xcconfig-files-for-maintaining-targets-configurations.html">http://szulctomasz.com/2015/11/14/xcode-xcconfig-files-for-maintaining-targets-configurations.html</a></p><p><a href="https://www.appcoda.com/xcconfig-guide/">https://www.appcoda.com/xcconfig-guide/</a></p><p><a href="https://medium.com/@derrickho_28266/xcconfig-swift-macros-9aca99e36c5e">https://medium.com/@derrickho_28266/xcconfig-swift-macros-9aca99e36c5e</a></p><p><a href="https://developer.apple.com/library/content/documentation/Swift/Conceptual/BuildingCocoaApps/InteractingWithCAPIs.html">https://developer.apple.com/library/content/documentation/Swift/Conceptual/BuildingCocoaApps/InteractingWithCAPIs.html</a></p>]]></content:encoded></item><item><guid isPermaLink="true">https://jjorgemoura.com/tips/ChildViewControllers</guid><title>Child ViewControllers</title><description></description><link>https://jjorgemoura.com/tips/ChildViewControllers</link><pubDate>Sat, 16 May 2020 09:56:20 +0000</pubDate><content:encoded><![CDATA[<h1>Child ViewControllers</h1><p>We can have one ViewController with multiple child ViewControllers. The anology is similar with a view with multiple subviews. In practice, a ViewController can handle their view and their multiple subviews or have the subviews being handled by their correspondent ViewControllers.</p><p>In case we want to add childViewControllers, we need to:</p><pre><code>// in a ViewController
func displayContentController(content: UIViewController) {
    addChildViewController(content)
    self.view.addSubview(content.view)
    content.didMove(toParentViewController: self)
}
</code></pre><p>As a opposite operation, we have:</p><pre><code>// in a ViewController
func hideContentController(content: UIViewController) {
    content.willMove(toParentViewController: nil)
    content.view.removeFromSuperview()
    content.removeFromParentViewController()
}
</code></pre><p><strong>Resources</strong></p><p><a href="https://developer.apple.com/library/content/featuredarticles/ViewControllerPGforiPhoneOS/ImplementingaContainerViewController.html">https://developer.apple.com/library/content/featuredarticles/ViewControllerPGforiPhoneOS/ImplementingaContainerViewController.html</a></p><p><a href="https://www.swiftbysundell.com/posts/using-child-view-controllers-as-plugins-in-swift">https://www.swiftbysundell.com/posts/using-child-view-controllers-as-plugins-in-swift</a></p><p><a href="https://github.com/codepath/ios_guides/wiki/Container-View-Controllers-Quickstart">https://github.com/codepath/ios_guides/wiki/Container-View-Controllers-Quickstart</a></p>]]></content:encoded></item><item><guid isPermaLink="true">https://jjorgemoura.com/tips/ClassStructs</guid><title>Swift Struct vs Class</title><description></description><link>https://jjorgemoura.com/tips/ClassStructs</link><pubDate>Sat, 16 May 2020 09:56:20 +0000</pubDate><content:encoded><![CDATA[<h1>Swift Struct vs Class</h1><p>Swift supports entities to be value types (structs) or reference types (classes).</p><p>Let start we the common features between class and structs. Both support:</p><ul><li>properties</li><li>methods</li><li>subscrips</li><li>init method</li><li>suport extensions</li><li>conform to protocols</li></ul><p>However, classes support a bit more features:</p><ul><li>inheritance</li><li>deinit</li><li>multiple references</li></ul><h2>Struct</h2><p>A struct is a value type. Each time we pass a instance around (function parameter) or set to a different variable, it creates (and copy) a new instance with the same value.</p><p>If we init a struct as a <code>let</code>, we can't mutate (change) any value of that instance.</p><pre><code>let lStruct = StructA()
lStruct.title = "new Title"
//compilation error

var vStruct = StructA()
vStruct.title = "new Title"
//compiles
</code></pre><h2>Class</h2><p>Even if the declare a variable as <code>let</code>, we can change the value of one of its properties because we are not mutating the value of the var because its value is a reference to a memory address where resides the actual values.</p><p>Classes support operators === and !== which are used to check whether two variables or constants refer to the same instance.</p><pre><code>var instanceA = TheParent()
var instanceB = TheParent()
var instanceC = TheParent()
instanceC = instanceA

instanceA == instanceB      //true
instanceA === instanceB     //false

instanceA == instanceC      //true
instanceA === instanceC     //true
</code></pre><h2>Value Type Vs Reference Type</h2><p>A <strong>Value Type</strong> holds the data within its own memory allocation and a Reference Type contains a pointer to another memory location that holds the real data. Reference Type variables are stored in the heap while Value Type variables are stored in the stack.</p><p>All structures and enumerations are value types in Swift. This means that any structure and enumeration instances you create—and any value types they have as properties—are always copied when they are passed around in your code.</p><p>In Swift, many basic data types such as String, Array, and Dictionary are implemented as structures. This means that data such as strings, arrays, and dictionaries are copied when they are assigned to a new constant or variable, or when they are passed to a function or method.</p><p>This behaviour is different from Foundation: NSString, NSArray, and NSDictionary are implemented as classes, not structures. Strings, arrays, and dictionaries in Foundation are always assigned and passed around as a reference to an existing instance, rather than as a copy.</p><h2>Get class type</h2><p>We can get/print the class type calling self to the type.</p><pre><code>let stringType = String.self
let anotherStringType = String(describing: stringType)
print(stringType)
print(anotherStringType)
// Both print `String`
</code></pre><p>This is the same for structs or variables.</p><h3>Resources</h3><p><a href="http://faq.sealedabstract.com/structs_or_classes/">http://faq.sealedabstract.com/structs<em>or</em>classes/</a></p><p><a href="https://codeinswift.blogspot.co.uk/2016/11/class-vs-struct-in-swift.html">https://codeinswift.blogspot.co.uk/2016/11/class-vs-struct-in-swift.html</a></p>]]></content:encoded></item><item><guid isPermaLink="true">https://jjorgemoura.com/tips/CodeSnippetBuilder</guid><title>Design Patterns -&gt; Builder</title><description></description><link>https://jjorgemoura.com/tips/CodeSnippetBuilder</link><pubDate>Sat, 16 May 2020 09:56:20 +0000</pubDate><content:encoded><![CDATA[<h1>Design Patterns -&gt; Builder</h1><p>From Wikipedia: &gt; The builder pattern is an object creation software design pattern. Unlike the abstract factory pattern and the factory method pattern whose intention is to enable polymorphism, the intention of the builder pattern is to find a solution to the telescoping constructor anti-pattern that occurs when the increase of object constructor parameter combination leads to an exponential list of constructors. Instead of using numerous constructors, the builder pattern uses another object, a builder, that receives each initialization parameter step by step and then returns the resulting constructed object at once.</p><p>Another definition is:</p><blockquote><p>The builder pattern is used to create complex objects with constituent parts that must be created in the same order or using a specific algorithm. An external class controls the construction algorithm.</p></blockquote><p>A swift example is:</p><p>For Swift, there are several examples with minor differences. Check [2] and [3] for two very similar examples. The example in [2] we have 2 diffent objects, the class and the build itself. In option [3], it's all done inside the class.</p><p>Option [2]</p><pre><code>class DeathStarBuilder {
    var x: Double?
    var y: Double?
    var z: Double?

    typealias BuilderClosure = (DeathStarBuilder) -&gt; ()

    init(buildClosure: BuilderClosure) {
        buildClosure(self)
    }
}

struct DeathStar : CustomStringConvertible {
    let x: Double
    let y: Double
    let z: Double

    init?(builder: DeathStarBuilder) {
        if let x = builder.x, let y = builder.y, let z = builder.z {
            self.x = x
            self.y = y
            self.z = z
        } else { return nil }
    }
}

//usage
let empire = DeathStarBuilder { builder in
    builder.x = 0.1
    builder.y = 0.2
    builder.z = 0.3
}

let deathStar = DeathStar(builder:empire)
</code></pre><p>Option [3]:</p><pre><code>class Theme : ThemeProtocol {
    var backgroundColor:UIColor?
    var textColor:UIColor?
    
    typealias buildThemeClosure = (Theme) -&gt; Void
    
    init(build:buildThemeClosure) {
        build(self)
    }
}

//usage
let darkTheme = Theme(build: {
    $0.backgroundColor = UIColor.blackColor()
    $0.textColor = UIColor.whiteColor()
})
</code></pre><p>The limitation of option 2 is that the properties need to be public. The properties can not be private.</p><p>The option [3] it's very similar with the current technique to initialise UI classes, as we can see here:</p><pre><code> let helloWorldLbl:UILabel = {  
    let lbl = UILabel()
    lbl.text = self.someFunctionToDetermineText()
    lbl.font = UIFont.preferredFontForTextStyle(UIFontTextStyleBody)
    lbl.textColor = self.myAppTheme.textColor()
    lbl.textAlignment = .Center
    return lbl
}()
</code></pre><p>In terms of create code snippets, we can have these:</p><pre><code>class &lt;#XPTO#&gt;Builder {

    var x: String?
    var p: Int?
    var t: Bool = false

    typealias BuilderClosure = (&lt;#XPTO#&gt;Builder) -&gt; ()

    init(buildClosure: BuilderClosure) {
        buildClosure(self)
    }
}

class &lt;#XPTO#&gt; {

    let x: String
    let p: Int
    let t: Bool

    init?(builder: &lt;#XPTO#&gt;Builder) {
        if let x = builder.x, let p = builder.p {
            self.x = x
            self.p = p
            self.t = t
        } else {
            return nil
        }
    }
}
</code></pre><p><strong>Side note:</strong></p><p>We are now not using the Builder pattern very often. I can't remember exactly why but I think it's because Swift's default parameter capability. This makes that a class initialiser with multiple parameters will not be massive, ugly and difficult to use.</p><p><strong>Resources</strong></p><p>1 - <a href="https://en.wikipedia.org/wiki/Builder_pattern">https://en.wikipedia.org/wiki/Builder_pattern</a></p><p>2 - <a href="https://github.com/ochococo/Design-Patterns-In-Swift#creational">https://github.com/ochococo/Design-Patterns-In-Swift#creational</a></p><p>3 - <a href="https://medium.com/swift-programming/the-builder-pattern-in-swift-770d9cc1ac41">https://medium.com/swift-programming/the-builder-pattern-in-swift-770d9cc1ac41</a></p><p>4 - <a href="https://github.com/kingreza/Swift-Builder">https://github.com/kingreza/Swift-Builder</a></p><p>5 - <a href="https://www.raywenderlich.com/86053/intermediate-design-patterns-in-swift">https://www.raywenderlich.com/86053/intermediate-design-patterns-in-swift</a></p>]]></content:encoded></item><item><guid isPermaLink="true">https://jjorgemoura.com/tips/DesignPattersCreational</guid><title>Design Patterns - Creational</title><description></description><link>https://jjorgemoura.com/tips/DesignPattersCreational</link><pubDate>Sat, 16 May 2020 09:56:20 +0000</pubDate><content:encoded><![CDATA[<h1>Design Patterns - Creational</h1><p>Based on stackoverflow <a href="https://stackoverflow.com/questions/4209791/design-patterns-abstract-factory-vs-factory-method">post</a></p><h3>Static Factory</h3><p>Simple static method in base class.</p><img src="https://i.stack.imgur.com/5txhK.png "static factory"" alt="static factory"/><h3>Simple Factory</h3><p>Basically the same as in previous patterns but now the static method is in their own class.</p><img src="https://i.stack.imgur.com/O4mxc.png "simple factory"" alt="simple factory"/><h3>Factory Method</h3><p>The Simple Factory now delegates in their own subclasses the responsability of creating the classes (all subtypes of the main type).</p><img src="https://i.stack.imgur.com/nyqGK.png "factory method"" alt="factory method"/><h3>Abstract Factory</h3><p>Very similar with previous pattern but now each concrete factory create their own type of classes.</p><img src="https://i.stack.imgur.com/A6riH.png "abstract factory"" alt="abstract factory"/><h4>Resources:</h4><p><a href="https://stackoverflow.com/questions/4209791/design-patterns-abstract-factory-vs-factory-method">https://stackoverflow.com/questions/4209791/design-patterns-abstract-factory-vs-factory-method</a></p><p><a href="http://oo-programming.blogspot.co.uk/2009/02/oo-design-principles.html">http://oo-programming.blogspot.co.uk/2009/02/oo-design-principles.html</a></p>]]></content:encoded></item><item><guid isPermaLink="true">https://jjorgemoura.com/tips/FileOrganization</guid><title>File Organization</title><description></description><link>https://jjorgemoura.com/tips/FileOrganization</link><pubDate>Sat, 16 May 2020 09:56:20 +0000</pubDate><content:encoded><![CDATA[<h1>File Organization</h1><p>This is a really important topic for me. Usaually I care a lot about the order of the code in a class. After checking this <a href="http://blog.jaredsinclair.com/post/152672541355/how-i-organize-a-swift-file">article</a> on how to organize code in a swift file, I decided to write down my own rules and preferences:.</p><p>The order of the code must be reinforced with the use of <code>MARK:</code> comments.</p><p>My order is:</p><ul><li>class / static Properties</li></ul><ul><li>IBOutlets Properties</li></ul><ul><li>UIViewController (override) Properties</li></ul><ul><li>Public/Internal weakProperties</li></ul><ul><li>Public/Internal Properties</li></ul><ul><li>Private Contants</li></ul><ul><li>Private Properties</li></ul><ul><li>Init / Deinit</li></ul><ul><li>UIViewController Lifecycle Methods</li></ul><ul><li>Public Methods</li></ul><ul><li>XXXXDelegate Methods</li></ul><ul><li>YYYYDelegate Methods</li></ul><ul><li>Private Methods<ul></ul></li></ul><p>All these blocks should be used as:</p><p><code>// MARK: xxxxx</code></p><p>If one block is not used in a particular class / struct then we should omit it.</p><p>One of the doubs is if we should keep the use of extensions to add protocol/delegation conformity or include those variables and/or methods inside the main body structure.</p>]]></content:encoded></item><item><guid isPermaLink="true">https://jjorgemoura.com/tips/IBOutlets</guid><title>IBOutlets</title><description></description><link>https://jjorgemoura.com/tips/IBOutlets</link><pubDate>Sat, 16 May 2020 09:56:20 +0000</pubDate><content:encoded><![CDATA[<h1>IBOutlets</h1><p>Recently I got some doubts about the correct way of declare <code>IBOutlets</code>.</p><p>Taking as starting point this <a href="http://scottberrevoets.com/2016/03/21/outlets-strong-or-weak/">article</a>, I need to better understand all the bits in:</p><pre><code class="language-swift">@IBOutlet private weak var someLabel: UILabel!
</code></pre><p>Some of this keywords are fixed (the <code>IBOutlet</code>, the <code>var</code>), however others can be different based on each particular case.</p><p>The main decisions are:</p><h4>Private or Internal</h4><p>Should be always <code>private</code>, unless some weird design is on place.</p><h4>? or ! (Optional or Implicitly Unwrapped Optional)</h4><p>The safest option is being an <code>Optional</code>.</p><p>Most of the times is safe to use <code>Implicitly Unwrapped Optional</code>. Of course if we have view that we remove from the view hierarchy, in that case it should be optional.</p><p>A important case to bare in mind is when we are using storyboards. Often with Storyboards, when we can access the ViewController during <code>prepareForSegue(_:sender:)</code>, the IBOutlets will be still nil because the view is not loaded yet. Most of the times we access the ViewController this way in order to perform some setup that set some label texts.</p><p>All the other cases, the IBOutlet should have an value. If not, probably is a bug in our code.</p><h4>Weak or Strong</h4><p>It seems we should use always <code>strong</code>. From Apple:</p><blockquote><p>And the last option I want to point out is the storage type, which can either be strong or weak. In general you should make your outlet strong, especially if you are connecting an outlet to a subview or to a constraint that's not always going to be retained by the view hierarchy. The only time you really need to make an outlet weak is if you have a custom view that references something back up the view hierarchy and in general that's not recommended.</p></blockquote><p>Using <code>strong</code> is the current recommended best practice unless <code>weak</code> is specifically needed to avoid a retain cycle.</p><h4>Conclusion</h4><p>Typically we should have Weak Optionals and Strong Implicitly Unwrapped Optionals.</p><p><code>@IBOutlet private weak var someLabel: UILabel?</code></p><p>and</p><p><code>@IBOutlet private var someLabel: UILabel!</code></p><p>Probably I'm going with this last practice, strong and Implicitly Unwrapped.</p>]]></content:encoded></item><item><guid isPermaLink="true">https://jjorgemoura.com/tips/LocalisedPlurals</guid><title>LocalisedStrigns -&gt; Plurals</title><description></description><link>https://jjorgemoura.com/tips/LocalisedPlurals</link><pubDate>Sat, 16 May 2020 09:56:20 +0000</pubDate><content:encoded><![CDATA[<h1>LocalisedStrigns -&gt; Plurals</h1><p>This is a complex subject, mainly due to a lack of documentation from Apple.</p><p>Some notes:</p><p><code>NSStringLocalizedFormatKey</code> -&gt; This must be <code>%#@points@</code> for the first parameter or <code>%3$#@points@</code> if we want to specify an order (both use a variable named <code>points</code>).</p><p>In order to use the parameters in the final strings, we can refer the parameters as <code>%2$@</code> for a string, <code>%2$d</code> for an integer, etc.</p><p><strong>Note:</strong></p><p>LocalisedStrings format the strings and integers based on locale.</p><p><strong>Resources</strong></p><p><a href="https://developer.apple.com/library/content/documentation/MacOSX/Conceptual/BPInternational/StringsdictFileFormat/StringsdictFileFormat.html">https://developer.apple.com/library/content/documentation/MacOSX/Conceptual/BPInternational/StringsdictFileFormat/StringsdictFileFormat.html</a></p><p><a href="https://forums.developer.apple.com/thread/75806">https://forums.developer.apple.com/thread/75806</a></p><p><a href="https://www.objc.io/issues/9-strings/string-localization/">https://www.objc.io/issues/9-strings/string-localization/</a></p><p><a href="https://www.raizlabs.com/dev/2017/03/localized-pluralization-with-stringsdict/">https://www.raizlabs.com/dev/2017/03/localized-pluralization-with-stringsdict/</a></p><p><a href="https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/Strings/Articles/formatSpecifiers.html">https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/Strings/Articles/formatSpecifiers.html</a></p>]]></content:encoded></item><item><guid isPermaLink="true">https://jjorgemoura.com/tips/MVVMCoordinators</guid><title>MVVM Coordinators</title><description></description><link>https://jjorgemoura.com/tips/MVVMCoordinators</link><pubDate>Sat, 16 May 2020 09:56:20 +0000</pubDate><content:encoded><![CDATA[<h1>MVVM Coordinators</h1><p>There is thousands of articles about MVVM, with or without coordinators, with or without Rx, etc.</p><p>Let's focus on MVVM-C + RxSwift.</p><p>I'm focusing in how to separate and articulate all the pieces in this architecture.</p><p>One of the best articles about these theme is the <a href="https://blog.uptech.team/taming-great-complexity-mvvm-coordinators-and-rxswift-8daf8a76e7fd">Taming Great Complexity: MVVM, Coordinators and RxSwift</a> - <a href="https://github.com/uptechteam/Coordinator-MVVM-Rx-Example">github</a></p><h3>Model</h3><p>The model, the business model and logic. The classes should have methods (behaviour) and properties (state).</p><p>With most of the data being retrieved from Web Services nowadays, the model can be only the data classes that map the json retrieved.</p><p>In case we have also a local DB, it could became more complicated the coexistence of both json data and db data because one need to implement Codable/Decodable and the other the NSManagedObject. In this particular case I would say we can have a shadow object to be the NSManagedObject. Unless, of course, the DB acts as a "No-SQL" and where we store the JSON straightaway. In that particular, we can reuse the same object.</p><h3>ViewModel</h3><p>There is a huge risk in this became a MVM, a Massive VM. We need to take particular attention to not put here to much stuff. We can break stuff in several sub-VMs. Is the responsability of the VM to trigger the network calls, DB calls, "process the responses" and prepare the data to be presented by the VC.</p><h3>View/ViewController</h3><p>Only responsible for the presentation of the data. Knows about the VM but not the Model. If using Rx, we can bind the actions and the ui controls to Rx objects in the VM.</p><h3>Coordinator</h3><p>Perform all the navigation. Is the respobilibity of the coordinator to instanciate the VM, the VC and inject the VM into the VC.</p><p><strong>Resources</strong></p><p><a href="https://www.youtube.com/watch?v=VzbllBC5eec">https://www.youtube.com/watch?v=VzbllBC5eec</a></p>]]></content:encoded></item><item><guid isPermaLink="true">https://jjorgemoura.com/tips/MVVMNavigation</guid><title>MVVM Navigation</title><description></description><link>https://jjorgemoura.com/tips/MVVMNavigation</link><pubDate>Sat, 16 May 2020 09:56:20 +0000</pubDate><content:encoded><![CDATA[<h1>MVVM Navigation</h1><h2>Architecture</h2><p>One problem I've been facing is move from the simplistic examples we see in the articles and presentations to one real life complex codebase.</p><p>One of the main issues I've been facing is how handle the Model objects in the Views. In particularly, in the case where the model object is a Core Data managed object, a json decodable object or both at same time.</p><p>After some digging, I can see that:</p><ul><li>Model objects can go into Views, basically via the ViewModel. The thought is, if a model entity contains 20 parameters, probably doesn't make sense to create 20 parameters in the ViewModel in order to seperate the view from the model. The best approach should be the ViewModel to contain an instance of the Model.</li></ul><p>If the case where we have a Data Base, then should exist a layer to translate the model with the ManagedObject. In the case we have a Model build from the Web Services, then it should be fine to have the object sent to View. The main issue is the possible differences between the response json and the internal domain. In those cases we can always create a custom decoding mapping.</p><p><strong>Model</strong></p><p><code>X</code></p><p><code>XService</code> -&gt; Makes reomte call and returns Rx Stream of <code>[X]</code></p><p><strong>ViewModel</strong></p><p><code>XListViewModel</code> -&gt; Rx Stream with <code>[XViewModel]</code> build from XService stream of <code>[X]</code> transformed to <code>[XViewModel]</code></p><p><code>XViewModel</code> -&gt; Init with X. Instead of access X, access could be done via computed properties.</p><p><strong>View</strong></p><p><code>XListViewController</code> -&gt; observes Rx Stream from ViewModel</p><p><code>XCellViewController</code> -&gt; init with XViewModel</p><p><code>XViewController</code> -&gt; Init with X or XViewModel</p><p>Tracking user inputs is through the ViewModel.</p><h3>Some notes</h3><ul><li>A good way to navigate between VC using MVVM is through coordinators, in conjunction with the avoidance of using storyboards.</li></ul><ul><li>We should navigate from the VM instead of the VC (as it's stated in the AppArchitecture book). However this is better achieved when using Rx.</li></ul><ul><li>In order to avoid using a <strong>massive</strong> VM, we should break it on small components, such as <code>Loaders/DataSource</code>, <code>Binding</code>, <code>Service</code>, etc.</li></ul><ul><li>The VM can retrieve primitive fields but also some other types (consider small VM).</li></ul><ul><li>The VM should be agnostic of the View technology. Imagine in a UICollectionView. We should be able to replace it by IGListKit without having the need of change the VM.</li></ul><ul><li>The M can be pass to the View. However, this M cannot be the Managed Object (Core Data). M should be only the businesss/domain object. Probably it's fine if M is the decodable object, eventually with more data and functions.</li></ul><ul><li>If we need to present a DataSource for a TableView, then the main VM returns an array of <code>cellVM</code>.</li></ul><ul><li>There is the concept of reusable VM. Basically is if the VM can be changed/updated. So, not being a let variable injected durint init but an, eventually, optional property.</li></ul><p><strong>Resources</strong></p><p><a href="http://www.danielhall.io/the-problems-with-mvvm-on-ios">http://www.danielhall.io/the-problems-with-mvvm-on-ios</a></p><p><a href="http://merowing.info/2016/08/better-mvvm-setup-with-pop-and-runtime/">http://merowing.info/2016/08/better-mvvm-setup-with-pop-and-runtime/</a></p><p><a href="http://holko.pl/2016/03/29/storyboards-and-alternatives/">http://holko.pl/2016/03/29/storyboards-and-alternatives/</a></p><p><a href="https://artsy.github.io/blog/2015/09/24/mvvm-in-swift/">https://artsy.github.io/blog/2015/09/24/mvvm-in-swift/</a></p><p><a href="https://medium.com/flawless-app-stories/how-to-use-a-model-view-viewmodel-architecture-for-ios-46963c67be1b">https://medium.com/flawless-app-stories/how-to-use-a-model-view-viewmodel-architecture-for-ios-46963c67be1b</a></p>]]></content:encoded></item><item><guid isPermaLink="true">https://jjorgemoura.com/tips/ModuleImports</guid><title>Simplifying Swift Framework development</title><description></description><link>https://jjorgemoura.com/tips/ModuleImports</link><pubDate>Sat, 16 May 2020 09:56:20 +0000</pubDate><content:encoded><![CDATA[<h1>Simplifying Swift Framework development</h1><p>Based on <a href="https://davedelong.com/blog/2018/01/19/simplifying-swift-framework-development/">this</a> article from <a href="https://davedelong.com">Dave DeLong</a>, we got some useful tips for framework development.</p><p>Tips are:</p><ul><li>Avoid repeat the same <code>import DependencyA</code> amongst several classes</li></ul><ul><li>access <code>Bundle</code> correctly and easily.</li></ul><p>This piece of code give us the answer:</p><pre><code>// CoreAwesome.swift
@_exported import Foundation
@_exported import DependencyA
@_exported import DependencyB

public let CoreAwesomeBundle = Bundle(for: CoreAwesomeMarker.self)

private class CoreAwesomeMarker { }
</code></pre><p>I made a tweak here to be more clear and fix a mentioned issue.</p><p><strong>Resource</strong></p><p><a href="https://davedelong.com/blog/2018/01/19/simplifying-swift-framework-development/">https://davedelong.com/blog/2018/01/19/simplifying-swift-framework-development/</a></p>]]></content:encoded></item><item><guid isPermaLink="true">https://jjorgemoura.com/tips/OpenClosePrinciple</guid><title>Swift Enums breaks the Open/Close Principle</title><description></description><link>https://jjorgemoura.com/tips/OpenClosePrinciple</link><pubDate>Sat, 16 May 2020 09:56:20 +0000</pubDate><content:encoded><![CDATA[<h1>Swift Enums breaks the Open/Close Principle</h1><p>This idea is analised on this <a href="https://medium.com/@rjchatfield/the-expression-problem-in-swift-6f2471291604">article</a>.</p><p>Basically, my idea, after have read the article is that Swift <code>Enums</code> are bad if <em>"any new case to the enum implies changes in existing case code"</em>.</p><p>Simple as that.</p><p>For more information, is read the articles :)</p><p><strong>Resouces </strong></p><p><a href="https://medium.com/@rjchatfield/the-expression-problem-in-swift-6f2471291604">https://medium.com/@rjchatfield/the-expression-problem-in-swift-6f2471291604</a></p><p><a href="https://stackoverflow.com/questions/40396639/swift-extend-an-enum-for-only-one-of-its-cases">https://stackoverflow.com/questions/40396639/swift-extend-an-enum-for-only-one-of-its-cases</a></p>]]></content:encoded></item><item><guid isPermaLink="true">https://jjorgemoura.com/tips/ProtocolNaming</guid><title>Protocol Naming</title><description></description><link>https://jjorgemoura.com/tips/ProtocolNaming</link><pubDate>Sat, 16 May 2020 09:56:20 +0000</pubDate><content:encoded><![CDATA[<h1>Protocol Naming</h1><p>While doing some work using the MVVM+Coordinators acchitecture, one of the first problems I have faced was naming, more precisily what to call to ViewModels, both their types (protocol) and implementation classes.</p><p>Of course we can use MVVM without the use of protocols to typify the ViewModels. However, there is n+1 <a href="https://www.raywenderlich.com/148448/introducing-protocol-oriented-programming">articles</a> out there advocating the vantages of <a href="https://developer.apple.com/videos/play/wwdc2015/408/">Protocol-Oriented Programming</a>.</p><p>One of the rules I'm following while using MVVM is refer all the ViewModels through their protocol type.</p><p>This raises, immediatly, the question, how to name both the ViewModel's protocol and complient classes.</p><p>My main rule was try to comply mush as possible with the official recomendations and best practices.</p><p>Apple's <a href="https://swift.org/documentation/api-design-guidelines/">guidelines</a> for protocols are:</p><blockquote><p>Protocols that describe what something is should read as nouns (e.g. Collection).</p></blockquote><blockquote><p>Protocols that describe a capability should be named using the suffixes able, ible, or ing (e.g. Equatable, ProgressReporting).</p></blockquote><p>In our case, that is to name ViewModels, we should read them as nous because their role are being types.</p><p><strong>First decision:</strong></p><p>Which one should keep the canonical name, the protocol or the class? Supposing we have a ViewModel for UserPreferences. Naturally, we will have a UserPreferencesViewModel. Is this UserPreferencesViewModel that I consider the canonical name. So, should UserPreferencesViewModel be the name of the protocol and call something else to all the classes that comply? Or should we call the protocol UserPreferencesViewModelProtocol (or other thing, such: Type) and the UserPreferencesViewModel the default class?</p><p>This decision is pretty easy to make. While the protocol reference will be spread all over the code, the class name will be used just once, during their init. So, it's the protocol that should uise the canonical nomenclature. This is consistent with Apple's rules and practices.</p><p><strong>Second decision</strong></p><p>This is the tough one. What to call the classe that actually is our viewModel. One of the Swift code conventions is, do not use abbreviations. This immediatle rule out the Imp / Impl suffix.</p><p>In this type of cases, where we end up one having one implementions (other than the fake one for tests), are the difficult ones. When this happens, I tend to naturally call then as the "default" or "standard" viewModel. However, using those words as prefix doesn't make to much sense and also hurts the readability/searchability of all different kind of classes for a specific feature. Imagine we will have the UserView, UserViewController, UserViewModel, User, UserService and StandardUserViewModel! Doesn't seems tidy.</p><p>I also didn't found a nice suffix, something that reads naturally. The most natural naming always ends with "view model".</p><p>After several tries, I end up calling it "SomethingDefaultViewModel". So, I'm still using the "default" word but move it from being a prefix to be in the middle of the name, just before the "ViewModel". In this particular example, I would use UserDefaultViewModel. Some could argue it's not perfect or that is worse than other options. Fair, but for me it works and fulfill all my rules.</p>]]></content:encoded></item><item><guid isPermaLink="true">https://jjorgemoura.com/tips/RXSwift</guid><title>RxSwift</title><description></description><link>https://jjorgemoura.com/tips/RXSwift</link><pubDate>Sat, 16 May 2020 09:56:20 +0000</pubDate><content:encoded><![CDATA[<h1>RxSwift</h1><p>One of the possible definitions of Rx can be:</p><blockquote><p>Modeling a system using a series of composable streams of data, and eliminating stored state wherever possible.</p></blockquote><p>What Does Rx Bring?</p><ul><li>Stateless programming</li><li>Fewer bugs by eliminating state</li><li>Better local reasoning</li></ul><h2>Observables</h2><p>Observables are the way streams are represented in Rx.</p><p>We can generate an observable:</p><p><strong>- manually</strong></p><p>via:</p><ul><li>Observable.create</li></ul><p><strong>- automatically</strong></p><p>via:</p><ul><li>defer,</li><li>empty</li><li>never</li><li>throw</li><li>from</li><li>interval</li><li>just</li><li>range</li><li>repeat</li><li>start</li><li>timer</li></ul><p>NOTE: Note sure interilely about all these. Probably some of them are also manually created.</p><h2>Subjects</h2><p>There are four subject types in RxSwift:</p><p>• <strong>PublishSubject</strong>: Starts <code>empty</code> and only emits new elements to subscribers.</p><p>• <strong>BehaviorSubject</strong>: Starts with <code>an initial value</code> and replays it or the latest element to new subscribers. Kind of ReplaySubject but with buffer size of 1.</p><p>• <strong>ReplaySubject</strong>: Initialized with a <code>buffer size</code> and will maintain a buffer of elements up to that size and replay it to new subscribers.</p><p>• <strong>AsyncSubject</strong>: An AsyncSubject emits the last value (and only the last value) emitted by the source Observable only after that source completes. If the source Observable does not emit any values, or emits an error, the AsyncSubject also completes without emitting any values.</p><p>• <strong>Variable</strong>: Wraps a <strong>BehaviorSubject</strong>, preserves its current value as state, and replays only the latest/initial value to new subscribers. There is no way to add an .error or .completed event onto a variable. Any attempts to do so will generate compiler errors. So basically, Variable is a BehaviorSubject without error or completed. I think variable is now deprecated.</p><h2>Traits</h2><p>Documentation <a href="https://github.com/ReactiveX/RxSwift/blob/master/Documentation/Traits.md">here</a></p><h3>Driver</h3><p>Driver intention is to provide an intuitive way to write reactive code in the UI layer, or for any case where you want to model a stream of data Driving your application.</p><ul><li>Can't error out</li><li>Observe occurs on main scheduler</li><li>Shares side effects (shareReplayLatestWhileConnected)</li></ul><p>It is named Driver because its intended use case was to model sequences that drive your application.</p><p>E.g.</p><ul><li>Drive UI from CoreData model</li><li>Drive UI using values from other UI elements (bindings)</li></ul><p>Like normal operating system drivers, in case a sequence errors out, your application will stop responding to user input. It is also extremely important that those elements are observed on the main thread because UI elements and application logic are usually not thread safe.</p><p>Also, a Driver builds an observable sequence that shares side effects.</p><h3>Single</h3><p>A Single is a variation of Observable that, instead of emitting a series of elements, is always guaranteed to emit either a single element or an error.</p><ul><li>Emits exactly one element, or an error</li><li>Doesn't share side effects</li></ul><p>One common use case for using Single is for performing HTTP Requests that could only return a response or an error, but a Single can be used to model any case where you only care for a single element, and not for an infinite stream of elements.</p><h3>Completable</h3><p>A Completable is a variation of Observable that can only complete or emit an error. It is guaranteed to not emit any elements.</p><ul><li>Emits zero elements</li><li>Emits a completion event, or an error</li><li>Doesn't share side effects</li></ul><p>A useful use case for Completable would be to model any case where we only care for the fact an operation has completed, but don't care about a element resulted by that completion. You could compare it to using an Observable<Void> that can't emit elements.

### Maybe 

A Maybe is a variation of Observable that is right in between a Single and a Completable. It can either emit a single element, complete without emitting an element, or emit an error.

**Note**: Any of these three events would terminate the Maybe, meaning - a Maybe that completed can't also emit an element, and a Maybe that emitted an element can't also send a Completion event.

- Emits either a completed event, a single element or an error
- Doesn't share side effects

You could use Maybe to model any operation that could emit an element, but doesn't necessarily have to emit an element.


## RxCocoa

### Bind

Bind is a kind of `subscribe`. Stablish the observer link.



## Notes

### Side effects

What is `side effects`?

If you want to register callbacks that will be executed when certain events take place on an Observable Sequence you need to use the doOn Operator. It will not modify the emitted elements but rather just pass them through. 

- do(onNext:) - if you want to do something just if a next event happened
- do(onError:) - if errors will be emitted and
- do(onCompleted:) - if the sequence finished successfully.

```
Observable.of(1,2,3,4,5).do(onNext: {
    $0 * 10 // This has no effect on the actual subscription
}).subscribe(onNext:{
    print($0)
})

$ 1
$ 2
$ 3
$ 4
$ 5
```

More detailed:

Each subscription generates a new observable stream. Imagine the ones generated through `Obsevable.create`. We can ending up creating a different stream each time. So, in order to asssure the stream is the same, we can can `share()`. 

A similar concept and operator is the `shareReplay(i)`, used for when we want to the last i elements of a sequence, even after the sequence has terminated. 

>
The rule of thumb for using shareReplay(_) is to use it on any sequences you expect to complete. This way you prevent the observable from being re-created.
>

More and usefull info [here](https://medium.com/@_achou/rxswift-share-vs-replay-vs-sharereplay-bea99ac42168).

Basically the difference between `share` and `shareReplay(i)` is that when you subscribe with `shareReplay` you receive the previous(es) event(s) from buffer. Using `shareReplayLatestWhileConnected` basically is `shareReplay(i)` where `i = 1`.</p>]]></content:encoded></item><item><guid isPermaLink="true">https://jjorgemoura.com/tips/StaticDynamicLibraries</guid><title>Static Libraries vs Dynamic Frameworks</title><description></description><link>https://jjorgemoura.com/tips/StaticDynamicLibraries</link><pubDate>Sat, 16 May 2020 09:56:20 +0000</pubDate><content:encoded><![CDATA[<h1>Static Libraries vs Dynamic Frameworks</h1><h3>Library:</h3><ul><li>Static -&gt; Packaged into our code</li><li>Shared -&gt; Just a reference to the library that must reside on OS</li></ul><p>Static Library was the only option until iOS8. Static Library is a unit of code linked at compile time, which does not change. Static Library is generally used for simplifying the build system, where each major module is put into its own static library. This helps to avoid to much coupling. Then all the static libraries are linked together to make the final executable program. Libraries cannot contain images/assets.</p><p>With Library we need to ship the binary (.a) and headers separately.</p><h3><strong>Frameworks:</strong></h3><p>Libraries only has executable code. A framework is something more complete and powerfull. A framework is a bundle that contains shared libraries as well as sub directories of headers and other resources.</p><p>Frameworks are a unit of code and/or assets linked at runtime that may change.</p><h3>Differences</h3><ul><li>Inversion of Control is a key part which makes a framework different from a library. When we call a method from a library we are in control, but with the framework the control is inverted, the framework calls our code. (E.g a GUI framework calls our code through the event handlers).</li></ul><ul><li>A library is essentially a set of functions (well defined operations) that we can call. Each fucntion does some work and then returns the control to the client.</li></ul><ul><li>A framework embodies some abstract design with more behavior built in. In order to use it, we need to insert our behavior into various places in the framework either by subclassing or by plugging in our code. The framework code then calls our code at these points.</li></ul><ul><li>A framework can also be considered as a skeleton where the application defines the meat of the operation by filling out the skeleton. The skeleton still has code to link up the parts.</li></ul><h3>Libraries or Frameworks?</h3><p>Nowadays the common option is to use Frameworks. They can be a bit over engineering solution for some situations but overall, it's the best solution.</p><h3>Tutorials and samples</h3><p><a href="https://developer.apple.com/videos/play/wwdc2014/416/">Building Modern Frameworks (WWDC14)</a></p><p><a href="https://www.raywenderlich.com/65964/create-a-framework-for-ios">How to Create a Framework for iOS</a></p><p><a href="https://www.raywenderlich.com/126365/ios-frameworks-tutorial">Creating and Distributing iOS Frameworks</a></p><p><a href="https://robots.thoughtbot.com/creating-your-first-ios-framework">Creating your first iOS Framework</a></p><p><a href="https://blog.cocoapods.org/CocoaPods-0.36/">CocoaPods 0.36 - Framework and Swift Support</a></p><p><a href="https://artsy.github.io/blog/2015/01/04/cocoapods-and-frameworks/">CocoaPods and Frameworks</a></p><p><strong>Resources:</strong></p><p><a href="http://www.knowstack.com/framework-vs-library-cocoa-ios/">http://www.knowstack.com/framework-vs-library-cocoa-ios/</a></p>]]></content:encoded></item><item><guid isPermaLink="true">https://jjorgemoura.com/tips/SwiftOptionals</guid><title>Swift Optionals</title><description></description><link>https://jjorgemoura.com/tips/SwiftOptionals</link><pubDate>Sat, 16 May 2020 09:56:20 +0000</pubDate><content:encoded><![CDATA[<h1>Swift Optionals</h1><p>Swift has introduced (at least for the iOS development ecosystem) the concept of <a href="https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/TheBasics.html#//apple_ref/doc/uid/TP40014097-CH5-ID309">Optionals</a>.</p><p>An optional is a struct that can have two values, a nil value or "a" value.</p><p>From Apple's documentation: &gt; You use optionals in situations where a value may be absent. An optional represents two possibilities: Either there is a value, and you can unwrap the optional to access that value, or there isn’t a value at all.</p><p>Along the code we want/need to access those optionals. We can access through several ways:</p><h4>If Statements</h4><p>We can test, using the <code>if</code> statement, if an optinal is nil or not.</p><pre><code class="language-Swift">if convertedNumber != nil {
    print("convertedNumber contains some integer value.")
}
</code></pre><p>After testing for <code>nil</code>, if we want to access the value (already knowing that the variable is not nil), we can use the <em>Forced Unwrapping</em>.</p><h4>Forced Unwrapping</h4><p>Basically we force the unwrapping because we "are sure" that the optional contains a value:</p><pre><code class="language-Swift">if convertedNumber != nil {
    print("convertedNumber has an integer value of \(convertedNumber!).")
}
// Prints "convertedNumber has an integer value of 123."
</code></pre><p>This is, however, a bit verbose. It can also be dangerous if we avoid the if check based on the logic and in the "feeling" that such optional has a value.</p><h4>Optional Binding</h4><p>Is a more elegant and secure way of doing the unwrapp.</p><pre><code class="language-swift">if let actualNumber = Int(possibleNumber) {
    print("\"\(possibleNumber)\" has an integer value of \(actualNumber)")
} else {
    print("\"\(possibleNumber)\" could not be converted to an integer")
}
// Prints ""123" has an integer value of 123"
</code></pre><p>The main problem is that can be a bit verbose and cause a chain of optional bindings.</p><h4>Implicitly Unwrapped Optionals</h4><p>In some cases it’s clear from an optional will always have a value after some operation(ex: value first set). Thus, it’s useful to remove the need to always check and unwrap the optional’s value. This is because we can assumed that the optional has a value all of the time.</p><p>In that case we can use <em>implicitly unwrapped optionals</em>.</p><pre><code class="language-swift">let possibleString: String? = "An optional string."
let forcedString: String = possibleString! // requires an exclamation mark
 
let assumedString: String! = "An implicitly unwrapped optional string."
let implicitString: String = assumedString // no need for an exclamation mark
</code></pre><p>This requires some caution because: &gt; If an implicitly unwrapped optional is nil and you try to access its wrapped value, you’ll trigger a runtime error. The result is exactly the same as if you place an exclamation mark after a normal optional that doesn’t contain a value.</p>]]></content:encoded></item><item><guid isPermaLink="true">https://jjorgemoura.com/tips/SwiftSubscripting</guid><title>Swift Subscripting</title><description></description><link>https://jjorgemoura.com/tips/SwiftSubscripting</link><pubDate>Sat, 16 May 2020 09:56:20 +0000</pubDate><content:encoded><![CDATA[<h1>Swift Subscripting</h1><p>From Apple's documentation:</p><p>&gt; Classes, structures, and enumerations can define subscripts, which are shortcuts for accessing the member elements of a collection, list, or sequence. You use subscripts to set and retrieve values by index without needing separate methods for setting and retrieval. For example, you access elements in an Array instance as someArray[index] and elements in a Dictionary instance as someDictionary[key]. &gt; You can define multiple subscripts for a single type, and the appropriate subscript overload to use is selected based on the type of index value you pass to the subscript. Subscripts are not limited to a single dimension, and you can define subscripts with multiple input parameters to suit your custom type’s needs &gt;</p><p>Basically is the hability of using <code>product.title</code> or <code>product["title"]</code> for the same operation.</p><p>Some examples from Apple's documentation:</p><pre><code>struct TimesTable {
    let multiplier: Int
    subscript(index: Int) -&gt; Int {
        return multiplier * index
    }
}
let threeTimesTable = TimesTable(multiplier: 3)
print("six times three is \(threeTimesTable[6])")
// Prints "six times three is 18"
</code></pre><p>Let's have a look on a example with multiple parameters:</p><pre><code>struct Matrix {
    let rows: Int, columns: Int
    var grid: [Double]
    init(rows: Int, columns: Int) {
        self.rows = rows
        self.columns = columns
        grid = Array(repeating: 0.0, count: rows * columns)
    }
    func indexIsValid(row: Int, column: Int) -&gt; Bool {
        return row &gt;= 0 &amp;&amp; row &lt; rows &amp;&amp; column &gt;= 0 &amp;&amp; column &lt; columns
    }
    subscript(row: Int, column: Int) -&gt; Double {
        get {
            assert(indexIsValid(row: row, column: column), "Index out of range")
            return grid[(row * columns) + column]
        }
        set {
            assert(indexIsValid(row: row, column: column), "Index out of range")
            grid[(row * columns) + column] = newValue
        }
    }
}

///
matrix[0, 1] = 1.5
matrix[1, 0] = 3.2
</code></pre><h3>Resources</h3><p><a href="https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Subscripts.html">https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift<em>Programming</em>Language/Subscripts.html</a></p>]]></content:encoded></item><item><guid isPermaLink="true">https://jjorgemoura.com/tips/SymbolicBreakpoints</guid><title>Symbolic Breakpoint</title><description></description><link>https://jjorgemoura.com/tips/SymbolicBreakpoints</link><pubDate>Sat, 16 May 2020 09:56:20 +0000</pubDate><content:encoded><![CDATA[<h1>Symbolic Breakpoint</h1><p>As a best practice and as a development tool, we could use symbolic breakpoints that throw sounds and/or log messages, amoung other options, each time we pass through a "place".</p><p>A useful place could be the dealloc of a ViewController.</p><p>For example, add this log message: --- dealloc @(id)[$arg1 description]@ || @(id)[$arg1 title]@ || @"%B has been hit %H times"@</p><p>for the symbol: -[UIViewController dealloc]</p>]]></content:encoded></item><item><guid isPermaLink="true">https://jjorgemoura.com/tips/TestingOptionals</guid><title>Testing Optionals</title><description></description><link>https://jjorgemoura.com/tips/TestingOptionals</link><pubDate>Sat, 16 May 2020 09:56:20 +0000</pubDate><content:encoded><![CDATA[<h1>Testing Optionals</h1><p>Following Sundell <a href="https://www.swiftbysundell.com/posts/avoiding-force-unwrapping-in-swift-unit-tests">article</a> on <em>Avoiding force unwrapping in Swift unit tests</em>, a cheat sheet can be:</p><ul><li><strong>Sticking with optionals</strong></li></ul><p>Use this for the common cases where a mehod/var is an optional</p><ul><li><strong>Throwing tests</strong></li></ul><p>If the method <strong>throws</strong> an error, we should use <code>try</code> to call it. It will crash if it returns nil. The main code will use <code>try?</code>. - <strong>Encapsulate method to throws error</strong></p><p>If the method doesn't throws an error (and we don't want or can) add the throws, we can use an encapsulation method (through) an extension in order to replicate the same behaviour.</p>]]></content:encoded></item><item><guid isPermaLink="true">https://jjorgemoura.com/tips/TestingServers</guid><title>WireMock vs OHHTTPStubs</title><description></description><link>https://jjorgemoura.com/tips/TestingServers</link><pubDate>Sat, 16 May 2020 09:56:20 +0000</pubDate><content:encoded><![CDATA[<h1>WireMock vs OHHTTPStubs</h1><p><a href="http://wiremock.org">Wiremock</a> (<a href="https://github.com/tomakehurst/wiremock">github</a>) - A tool for mocking HTTP services</p><p><a href="https://github.com/AliSoftware/OHHTTPStubs">OHHTTPStubs</a> - Stub your network requests easily! Test your apps with fake network data and custom response time, response code and headers!</p><h3>Actors</h3><p>The names denounce two different approaches, a <code>mock</code> vs a <code>stub</code>.</p><p>First, let's have a look on some definitions:</p><p><strong>Dummy</strong> - just bogus values to satisfy the API.</p><blockquote><p>Example: If you're testing a method of a class which requires many mandatory parameters in a constructor which have no effect on your test, then you may create dummy objects for the purpose of creating new instances of a class.</p></blockquote><p><strong>Fake</strong> - create a test implementation of a class which may have a dependency on some external infrastructure. (It's good practice that your unit test does NOT actually interact with external infrastructure.)</p><blockquote><p>Example: Create fake implementation for accessing a database, replace it with in-memory collection.</p></blockquote><p><strong>Stub</strong> - override methods to return hard-coded values, also referred to as state-based.</p><p>I believe the biggest distinction is that a stub you have already written with predetermined behavior. So you would have a class that implements the dependency (abstract class or interface most likely) you are faking for testing purposes and the methods would just be stubbed out with set responses. They would not do anything fancy and you would have already written the stubbed code for it outside of your test.</p><blockquote><p>Example: Your test class depends on a method Calculate() taking 5 minutes to complete. Rather than wait for 5 minutes you can replace its real implementation with stub that returns hard-coded values; taking only a small fraction of the time.</p></blockquote><p><strong>Mock</strong> - very similar to Stub but interaction-based rather than state-based. This means you don't expect from Mock to return some value, but to assume that specific order of method calls are made.</p><p>A mock is something that as part of your test you have to setup with your expectations. A mock is not setup in a predetermined way so you have code that does it in your test. Mocks in a way are determined at runtime since the code that sets the expectations has to run before they do anything.</p><blockquote><p>Example: You're testing a user registration class. After calling Save, it should call SendConfirmationEmail.</p></blockquote><p>As a resume, stub is something you set as static. For example, a response to a specific request is a static json. A mock is something dynamic, that is built in runtime to return something for a specific request or call.</p><h4>Expectation</h4><p>Following these concepts, we can expect the OHHTTPStubs to be something more static, setup upfront, while the WireMock is expected to be something more flexible, dynamic and setup in runtime.</p><p>This <a href="https://medium.com/xcblog/network-stubbing-options-for-xctest-and-xcuitest-in-swift-2e0dcce9a37d">article</a> has a very good explanation about network tests.</p><p>The article points to several tools. However, lots of them are really small / incipient libs, things with just 3 starts!</p><p>I confess the Swift server side tool was a nice surprise.</p><p>At the end, it seems using Vapor is very similar with using Wire Mock, just that Vapor is a Swift server and Wire Mock a Java server.</p><p>Between OHHTTPStubs and Wire Mock, it seems we need to use a server for the UITests, so we can't use OHHTTPStubs for our UITests.</p><p>Also check <a href="https://medium.com/flawless-app-stories/the-complete-guide-to-network-unit-testing-in-swift-db8b3ee2c327">this</a> for additional info.</p>]]></content:encoded></item><item><guid isPermaLink="true">https://jjorgemoura.com/tips/Xcode</guid><title>Xcode</title><description></description><link>https://jjorgemoura.com/tips/Xcode</link><pubDate>Sat, 16 May 2020 09:56:20 +0000</pubDate><content:encoded><![CDATA[<h1>Xcode</h1><p>Xcode Tips</p><ul><li><a href="https://medium.com/ios-os-x-development/two-useful-environment-vars-6023b275c90c">Two very useful variables</a></li></ul>]]></content:encoded></item><item><guid isPermaLink="true">https://jjorgemoura.com/manifestos/testing</guid><title>The Testing Manifesto</title><description>The Testing Manifesto.</description><link>https://jjorgemoura.com/manifestos/testing</link><pubDate>Fri, 15 May 2020 20:00:00 +0000</pubDate><content:encoded><![CDATA[<h1>The Testing Manifesto</h1><p>My first post's text.</p>]]></content:encoded></item><item><guid isPermaLink="true">https://jjorgemoura.com/manifestos/pr</guid><title>The Pull Request Manifesto</title><description>The Pull Request Manifesto.</description><link>https://jjorgemoura.com/manifestos/pr</link><pubDate>Thu, 14 May 2020 20:00:00 +0000</pubDate><content:encoded><![CDATA[<h1>The Pull Request Manifesto</h1><p>My first post's text.</p>]]></content:encoded></item><item><guid isPermaLink="true">https://jjorgemoura.com/tips/SideEffects</guid><title>Side Effects</title><description>What is a side effect?</description><link>https://jjorgemoura.com/tips/SideEffects</link><pubDate>Tue, 12 May 2020 22:00:00 +0000</pubDate><content:encoded><![CDATA[<h1>Side Effects</h1><p>The term "Side Effect" applies to a function. A function has said to have / produce side effects of produce any change (logging, send data to analytics, etc) or perform any operation (mutates state) not necessary for their output data.</p>]]></content:encoded></item></channel></rss>