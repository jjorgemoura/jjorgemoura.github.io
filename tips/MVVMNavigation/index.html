<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"/><meta name="og:site_name" content="Cabulas"/><link rel="canonical" href="https://jjorgemoura.com/tips/MVVMNavigation"/><meta name="twitter:url" content="https://jjorgemoura.com/tips/MVVMNavigation"/><meta name="og:url" content="https://jjorgemoura.com/tips/MVVMNavigation"/><title>MVVM Navigation | Cabulas</title><meta name="twitter:title" content="MVVM Navigation | Cabulas"/><meta name="og:title" content="MVVM Navigation | Cabulas"/><meta name="description" content="I'm an iOS Software Engineer based in London"/><meta name="twitter:description" content="I'm an iOS Software Engineer based in London"/><meta name="og:description" content="I'm an iOS Software Engineer based in London"/><meta name="twitter:card" content="summary"/><link rel="stylesheet" href="/styles.css" type="text/css"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><link rel="shortcut icon" href="/images/favicon.png" type="image/png"/><link rel="alternate" href="/feed.rss" type="application/rss+xml" title="Subscribe to Cabulas"/></head><body class="item-page"><header><div class="wrapper"><a class="site-name" href="/">Cabulas</a><nav><ul><li><a href="/articles">Articles</a></li><li><a href="/manifestos">Manifestos</a></li><li><a class="selected" href="/tips">Tips</a></li><li><a href="/about">About</a></li></ul></nav></div></header><div class="wrapper"><article><div class="content"><h1>MVVM Navigation</h1><h2>Architecture</h2><p>One problem I've been facing is move from the simplistic examples we see in the articles and presentations to one real life complex codebase.</p><p>One of the main issues I've been facing is how handle the Model objects in the Views. In particularly, in the case where the model object is a Core Data managed object, a json decodable object or both at same time.</p><p>After some digging, I can see that:</p><ul><li>Model objects can go into Views, basically via the ViewModel. The thought is, if a model entity contains 20 parameters, probably doesn't make sense to create 20 parameters in the ViewModel in order to seperate the view from the model. The best approach should be the ViewModel to contain an instance of the Model.</li></ul><p>If the case where we have a Data Base, then should exist a layer to translate the model with the ManagedObject. In the case we have a Model build from the Web Services, then it should be fine to have the object sent to View. The main issue is the possible differences between the response json and the internal domain. In those cases we can always create a custom decoding mapping.</p><p><strong>Model</strong></p><p><code>X</code></p><p><code>XService</code> -&gt; Makes reomte call and returns Rx Stream of <code>[X]</code></p><p><strong>ViewModel</strong></p><p><code>XListViewModel</code> -&gt; Rx Stream with <code>[XViewModel]</code> build from XService stream of <code>[X]</code> transformed to <code>[XViewModel]</code></p><p><code>XViewModel</code> -&gt; Init with X. Instead of access X, access could be done via computed properties.</p><p><strong>View</strong></p><p><code>XListViewController</code> -&gt; observes Rx Stream from ViewModel</p><p><code>XCellViewController</code> -&gt; init with XViewModel</p><p><code>XViewController</code> -&gt; Init with X or XViewModel</p><p>Tracking user inputs is through the ViewModel.</p><h3>Some notes</h3><ul><li>A good way to navigate between VC using MVVM is through coordinators, in conjunction with the avoidance of using storyboards.</li></ul><ul><li>We should navigate from the VM instead of the VC (as it's stated in the AppArchitecture book). However this is better achieved when using Rx.</li></ul><ul><li>In order to avoid using a <strong>massive</strong> VM, we should break it on small components, such as <code>Loaders/DataSource</code>, <code>Binding</code>, <code>Service</code>, etc.</li></ul><ul><li>The VM can retrieve primitive fields but also some other types (consider small VM).</li></ul><ul><li>The VM should be agnostic of the View technology. Imagine in a UICollectionView. We should be able to replace it by IGListKit without having the need of change the VM.</li></ul><ul><li>The M can be pass to the View. However, this M cannot be the Managed Object (Core Data). M should be only the businesss/domain object. Probably it's fine if M is the decodable object, eventually with more data and functions.</li></ul><ul><li>If we need to present a DataSource for a TableView, then the main VM returns an array of <code>cellVM</code>.</li></ul><ul><li>There is the concept of reusable VM. Basically is if the VM can be changed/updated. So, not being a let variable injected durint init but an, eventually, optional property.</li></ul><p><strong>Resources</strong></p><p><a href="http://www.danielhall.io/the-problems-with-mvvm-on-ios">http://www.danielhall.io/the-problems-with-mvvm-on-ios</a></p><p><a href="http://merowing.info/2016/08/better-mvvm-setup-with-pop-and-runtime/">http://merowing.info/2016/08/better-mvvm-setup-with-pop-and-runtime/</a></p><p><a href="http://holko.pl/2016/03/29/storyboards-and-alternatives/">http://holko.pl/2016/03/29/storyboards-and-alternatives/</a></p><p><a href="https://artsy.github.io/blog/2015/09/24/mvvm-in-swift/">https://artsy.github.io/blog/2015/09/24/mvvm-in-swift/</a></p><p><a href="https://medium.com/flawless-app-stories/how-to-use-a-model-view-viewmodel-architecture-for-ios-46963c67be1b">https://medium.com/flawless-app-stories/how-to-use-a-model-view-viewmodel-architecture-for-ios-46963c67be1b</a></p></div><span>Tagged with: </span><ul class="tag-list"></ul></article></div><footer><p>Generated using <a href="https://github.com/johnsundell/publish">Publish</a>. This site is 100% Javascript free.</p><p>@ 2020 Jorge Moura.</p></footer></body></html>