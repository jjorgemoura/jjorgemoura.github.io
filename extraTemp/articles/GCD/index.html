<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"/><meta name="og:site_name" content="Cabulas"/><link rel="canonical" href="https://jjorgemoura.com/extraTemp/articles/GCD"/><meta name="twitter:url" content="https://jjorgemoura.com/extraTemp/articles/GCD"/><meta name="og:url" content="https://jjorgemoura.com/extraTemp/articles/GCD"/><title>Multi Threading | Cabulas</title><meta name="twitter:title" content="Multi Threading | Cabulas"/><meta name="og:title" content="Multi Threading | Cabulas"/><meta name="description" content="GCD - Grand Central Dispatch"/><meta name="twitter:description" content="GCD - Grand Central Dispatch"/><meta name="og:description" content="GCD - Grand Central Dispatch"/><meta name="twitter:card" content="summary"/><link rel="stylesheet" href="/styles.css" type="text/css"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><link rel="shortcut icon" href="/images/favicon.png" type="image/png"/><link rel="alternate" href="/feed.rss" type="application/rss+xml" title="Subscribe to Cabulas"/></head><body><header><div class="wrapper"><a class="site-name" href="/">Cabulas</a><nav><ul><li><a href="/articles">Articles</a></li><li><a href="/manifestos">Manifestos</a></li><li><a href="/tips">Tips</a></li><li><a href="/about">About</a></li></ul></nav></div></header><div class="wrapper"><h1>Multi Threading</h1><p>There is multiple APIs available that allow us to write multi-threading software.</p><p>Some of those available API for iOS are:</p><ul><li>Threads</li><li>Grand Central Dispatch (GCD)</li><li>NSOperationQueue</li><li>Run Loops</li></ul><p>Threads are subunits of processes. Operating system scheduler can schedule threads independently. Threads are, generally, the base of all concurrency APIs. &gt; Multiple threads can be executed at the same time on a single CPU core (or at least perceived as at the same time). The operating system assigns small slices of computing time to each thread, so that it seems to the user as if multiple tasks are executed at the same time. If multiple CPU cores are available, then multiple threads can be executed truly in parallel, therefore lessening the total time needed for a certain workload. &gt;</p><p>It's an OS scheduler's responsibility the management of the execution of the threads.</p><p>On iOS, the NSThread API is a simple Objective-C wrapper around pthreads. This API is a quite low level API when compared with GCD or NSOperationQueues.</p><p>Operation queues are a Cocoa abstraction of the queue model exposed by GCD. The main advantage of NSOperationQueues API over GCD is that the API is more well defined (more Objective-C like) and that the user can have more control over the execution of the queue, in particular, can cancel scheduled tasks.</p><p>Let's focus on <a href="https://developer.apple.com/documentation/dispatch">GCD</a>.</p><h2>Grand Central Dispatch</h2><p>GCD is based on the concept of queues, not threads. It's GCD's responsibility to transform the management of the queues in threads.</p><p>GCD decides on which particular thread the blocks of code are going to be executed on. Thus, is GCD's responsibility to manage how many threads are being created.</p><p>&gt; GCD exposes five different queues: the main queue running on the main thread, three background queues with different priorities, and one background queue with an even lower priority, which is I/O throttled. &gt;</p><p>There is a change in GCD API from Objective-C to Swift.</p><p>In Objective-C, the API looks more like C functions where, in Swift, the API looks more a native Swift API. The main class is <code>DispatchQueue</code>.</p><h3>Serial and Concurrent Queues</h3><p>A dispatch queue can be either serial or concurrent (parallel). On serial queues, the work items are executed one at a time. On concurrent queues, work items are dequeued (start to be executed) in order, but run all at once (at same time) and can finish in any order.</p><p>Both serial and concurrent queues process work items in first in, first-out (FIFO) order. Basically, they start to be executed/processed by scheduled order. It's the OS which determines how many concurrent jobs start to be executed.</p><h3>System-Provided Queues</h3><p>When an app launches, the system automatically creates a special queue called the main queue. Work items enqueued to the main queue execute serially on app’s main thread.</p><p>The system also creates a number of global concurrent dispatch queues. We can access the global concurrent queue that best matches a specified quality of service (QoS) using the global(attributes:) type method.</p><p><strong>Note (from Apple's docs):</strong> &gt; Attempting to synchronously execute a work item on the main queue results in dead-lock.&gt;</p><h3>QoS</h3><ul><li>userInteractive -&gt; The user-interactive quality of service class.</li><li>userInitiated -&gt; The user-initiated quality of service class.</li><li>default -&gt; The default quality of service class.</li><li>utility -&gt; The utility quality of service class.</li><li>background -&gt; The background quality of service class</li><li>unspecified -&gt; The absence of a quality of service class.</li></ul><h4>Some thoughts</h4><p>My idea is to keep it simple. This subject is already complex enough to keep adding even more complexity in managing multiple queues, with multiple QoS, of different kind (serial vs concurrent) and even adding some custom queues.</p><h4>Strategy</h4><p>Main queue -&gt; Only async -&gt; For UI related work</p><p>System queue (concurrent) -&gt; qos = default -&gt; network and other secondary work</p><p>System queue (concurrent) -&gt; qos = background -&gt; background work (when the app is not active)</p><p>Custom queue (serial) -&gt; qos = utility -&gt; some serial process (for example, apply a filter to an array of images)</p><h2>Thread Safety / Locks</h2><p>There are several uses of locks/synchonize.</p><p>Objective-C has a <code>@synchronized</code>. It seems that, no with Swift, are are some tricks to keep still be using this feature, in particular through their low level function <code>objc_sync_enter</code>.</p><p>However, using this should be avoided.</p><p>If we want to guarantee thread safety on, for example, setting a property, we should use DispatchQueue instead.</p><p>Check this <a href="http://basememara.com/creating-thread-safe-arrays-in-swift/">article</a> and <a href="https://medium.com/@oyalhi/dispatch-barriers-in-swift-3-6c4a295215d6">this</a> one.</p><p>Basically the strategy is use a queue to control the access to a specific variable, the one we want to guarantee to be thread safe.</p><p>If using a <code>Serial Queue</code>, we make the read operation <code>sync</code> in order to getters receive the value immediately (even though it could take a while to the job ton be processed thus this getter could block the calling thread). The setters should be <code>async</code>.</p><p>This way, because the queue is serial, all the requests (getter and setter) are executed one-by-one, in a FIFO queue, and only the getters are eventually delayed if the queue is really busy.</p><pre><code class="language-swift">private let serialQueue = DispatchQueue(label: “serialQueue”)
private var dictionary: [String: Any] = [:]

public func set(_ value: Any, forKey key: String) {
    serialQueue.sync {
        dictionary[key] = value
    }
}

public func object(forKey key: String) -&gt; Any? {
    var result: Any?

    serialQueue.sync {
        result = dictionary[key]
    }
    // returns after serialQueue is finished operation
    // because serialQueue is run synchronously
    return result
}
</code></pre><p>Alternative, we can use a <code>Concurrent Queue</code>.</p><pre><code class="language-swift">private let concurrentQueue = DispatchQueue(label: "concurrentQueue", attributes: .concurrent)
private var dictionary: [String: Any] = [:]

public func set(_ value: Any?, forKey key: String) {
    // .barrier flag ensures that within the queue all reading is done
    // before the below writing is performed and
    // pending readings start after below writing is performed
    concurrentQueue.async(flags: .barrier) {
        self.dictionary[key] = value
    }
}

public func object(forKey key: String) -&gt; Any? {
    var result: Any?

    concurrentQueue.sync {
        result = dictionary[key]
    }

    // returns after concurrentQueue is finished operation
    // because concurrentQueue is run synchronously
    return result
}
</code></pre><p>The difference is we can have multiple tasks running at same time. For getters that behaviour is desired. However, for getters, we don't want that. So the trick is to set a <code>barrier</code>. This flag makes the setter to behave a if it was a serial queue. Basically, it only starts when everything already queued finishes and nothing starts before this specific job is done. The <code>barrier</code> attribute is <code>flag</code> in a <code>DispatchWorkItem</code> and these flags are only valid for that specific item. It's kind of a temporary attribute of permission.</p><h2>Articles</h2><p><a href="https://www.objc.io/issues/2-concurrency/concurrency-apis-and-pitfalls/#grand-central-dispatch">https://www.objc.io/issues/2-concurrency/concurrency-apis-and-pitfalls/#grand-central-dispatch</a></p><p><a href="https://developer.apple.com/documentation/dispatch">https://developer.apple.com/documentation/dispatch</a></p><p><a href="https://www.raywenderlich.com/148513/grand-central-dispatch-tutorial-swift-3-part-1">https://www.raywenderlich.com/148513/grand-central-dispatch-tutorial-swift-3-part-1</a></p><p><a href="https://www.bobthedeveloper.io/blog/intro-to-grand-central-dispatch-in-swift-with-bob">https://www.bobthedeveloper.io/blog/intro-to-grand-central-dispatch-in-swift-with-bob</a></p><p><a href="http://basememara.com/creating-thread-safe-arrays-in-swift/">http://basememara.com/creating-thread-safe-arrays-in-swift/</a></p><p><a href="https://rhonabwy.com/2017/03/14/__trashed/">https://rhonabwy.com/2017/03/14/__trashed/</a></p><p><a href="https://medium.com/@oyalhi/dispatch-barriers-in-swift-3-6c4a295215d6">https://medium.com/@oyalhi/dispatch-barriers-in-swift-3-6c4a295215d6</a></p></div><footer><p>Generated using <a href="https://github.com/johnsundell/publish">Publish</a>. This site is 100% Javascript free.</p><p>@ 2020 Jorge Moura.</p></footer></body></html>