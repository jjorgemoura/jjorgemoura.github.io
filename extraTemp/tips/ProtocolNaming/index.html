<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"/><meta name="og:site_name" content="Cabulas"/><link rel="canonical" href="https://jjorgemoura.github.io/extraTemp/tips/ProtocolNaming"/><meta name="twitter:url" content="https://jjorgemoura.github.io/extraTemp/tips/ProtocolNaming"/><meta name="og:url" content="https://jjorgemoura.github.io/extraTemp/tips/ProtocolNaming"/><title>Protocol Naming | Cabulas</title><meta name="twitter:title" content="Protocol Naming | Cabulas"/><meta name="og:title" content="Protocol Naming | Cabulas"/><meta name="description" content="I'm an iOS Software Engineer"/><meta name="twitter:description" content="I'm an iOS Software Engineer"/><meta name="og:description" content="I'm an iOS Software Engineer"/><meta name="twitter:card" content="summary"/><link rel="stylesheet" href="/styles.css" type="text/css"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><link rel="shortcut icon" href="/images/favicon.png" type="image/png"/><link rel="alternate" href="/feed.rss" type="application/rss+xml" title="Subscribe to Cabulas"/></head><body><header><div class="wrapper"><a href="/" class="site-name">Cabulas</a><nav><ul><li><a href="/articles">Articles</a></li><li><a href="/tips">Tips</a></li><li><a href="/posts">My posts</a></li></ul></nav></div></header><div class="wrapper"><h1>Protocol Naming</h1><p>While doing some work using the MVVM+Coordinators acchitecture, one of the first problems I have faced was naming, more precisily what to call to ViewModels, both their types (protocol) and implementation classes.</p><p>Of course we can use MVVM without the use of protocols to typify the ViewModels. However, there is n+1 <a href="https://www.raywenderlich.com/148448/introducing-protocol-oriented-programming">articles</a> out there advocating the vantages of <a href="https://developer.apple.com/videos/play/wwdc2015/408/">Protocol-Oriented Programming</a>.</p><p>One of the rules I'm following while using MVVM is refer all the ViewModels through their protocol type.</p><p>This raises, immediatly, the question, how to name both the ViewModel's protocol and complient classes.</p><p>My main rule was try to comply mush as possible with the official recomendations and best practices.</p><p>Apple's <a href="https://swift.org/documentation/api-design-guidelines/">guidelines</a> for protocols are:</p><blockquote><p>Protocols that describe what something is should read as nouns (e.g. Collection). Protocols that describe a capability should be named using the suffixes able, ible, or ing (e.g. Equatable, ProgressReporting).</p></blockquote><p>In our case, that is to name ViewModels, we should read them as nous because their role are being types.</p><h2>First decision</h2><p>Which one should keep the canonical name, the protocol or the class? Supposing we have a ViewModel for UserPreferences. Naturally, we will have a UserPreferencesViewModel. Is this UserPreferencesViewModel that I consider the canonical name. So, should UserPreferencesViewModel be the name of the protocol and call something else to all the classes that comply? Or should we call the protocol UserPreferencesViewModelProtocol (or other thing, such: Type) and the UserPreferencesViewModel the default class?</p><p>This decision is pretty easy to make. While the protocol reference will be spread all over the code, the class name will be used just once, during their init. So, it's the protocol that should uise the canonical nomenclature. This is consistent with Apple's rules and practices.</p><h2>Second decision</h2><p>This is the tough one. What to call the classe that actually is our viewModel. One of the Swift code conventions is, do not use abbreviations. This immediatle rule out the Imp / Impl suffix.</p><p>In this type of cases, where we end up one having one implementions (other than the fake one for tests), are the difficult ones. When this happens, I tend to naturally call then as the "default" or "standard" viewModel. However, using those words as prefix doesn't make to much sense and also hurts the readability/searchability of all different kind of classes for a specific feature. Imagine we will have the UserView, UserViewController, UserViewModel, User, UserService and StandardUserViewModel! Doesn't seems tidy.</p><p>I also didn't found a nice suffix, something that reads naturally. The most natural naming always ends with "view model".</p><p>After several tries, I end up calling it "SomethingDefaultViewModel". So, I'm still using the "default" word but move it from being a prefix to be in the middle of the name, just before the "ViewModel". In this particular example, I would use UserDefaultViewModel. Some could argue it's not perfect or that is worse than other options. Fair, but for me it works and fulfill all my rules.</p></div><footer><p>Generated using <a href="https://github.com/johnsundell/publish">Publish</a></p><p><a href="/feed.rss">RSS feed</a></p></footer></body></html>