<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"/><meta name="og:site_name" content="Cabulas"/><link rel="canonical" href="https://jjorgemoura.com/extraTemp/ios/SoftwareDevelopmentPrinciples"/><meta name="twitter:url" content="https://jjorgemoura.com/extraTemp/ios/SoftwareDevelopmentPrinciples"/><meta name="og:url" content="https://jjorgemoura.com/extraTemp/ios/SoftwareDevelopmentPrinciples"/><title>Software Development Principles | Cabulas</title><meta name="twitter:title" content="Software Development Principles | Cabulas"/><meta name="og:title" content="Software Development Principles | Cabulas"/><meta name="description" content="I'm an iOS Software Engineer based in London"/><meta name="twitter:description" content="I'm an iOS Software Engineer based in London"/><meta name="og:description" content="I'm an iOS Software Engineer based in London"/><meta name="twitter:card" content="summary"/><link rel="stylesheet" href="/styles.css" type="text/css"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><link rel="shortcut icon" href="/images/favicon.png" type="image/png"/><link rel="alternate" href="/feed.rss" type="application/rss+xml" title="Subscribe to Cabulas"/></head><body><header><div class="wrapper"><a class="site-name" href="/">Cabulas</a><nav><ul><li><a href="/articles">Articles</a></li><li><a href="/manifestos">Manifestos</a></li><li><a href="/tips">Tips</a></li></ul></nav></div></header><div class="wrapper"><h1>Software Development Principles</h1><h2>SOLID</h2><p>==================================</p><h3>(S) -&gt; Single Responsibility Principle</h3><p>The single responsibility principle is a computer programming principle that states that every module, class, or function should have responsibility over a single part of the functionality provided by the software, and that responsibility should be entirely encapsulated by the class. All its services should be narrowly aligned with that responsibility</p><p><strong>Resouces</strong></p><p><a href="https://blog.cleancoder.com/uncle-bob/2014/05/08/SingleReponsibilityPrinciple.html">https://blog.cleancoder.com/uncle-bob/2014/05/08/SingleReponsibilityPrinciple.html</a></p><h3>(O) -&gt; Open-Close Principle</h3><p>Software entities should be open for extension, but closed for modification.</p><p>Bertrand Meyer is generally credited for having originated the term open/closed principle, which appeared in his 1988 book <em>Object Oriented Software Construction</em>.</p><blockquote><p>A module will be said to be open if it is still available for extension. For example, it should be possible to add fields to the data structures it contains, or new elements to the set of functions it performs.</p></blockquote><blockquote><p>A module will be said to be closed if [it] is available for use by other modules. This assumes that the module has been given a well-defined, stable description (the interface in the sense of information hiding).</p></blockquote><p>A clear and updated description is:</p><blockquote><p>A class is closed, since it may be compiled, stored in a library, baselined, and used by client classes. But it is also open, since any new class may use it as parent, adding new features. When a descendant class is defined, there is no need to change the original or to disturb its clients.</p></blockquote><h4>Swift Enums breaks the Open/Close Principle</h4><p>This idea is analised on this <a href="https://medium.com/@rjchatfield/the-expression-problem-in-swift-6f2471291604">article</a>.</p><p>Basically, my idea, after have read the article is that Swift <strong><em>Enums</em></strong> are bad if <em>"any new case to the enum implies changes in existing case code"</em>. More procisely, is a enum is suppose to be extended in the future, probably is not a good opion because, almost certenatily, will violate the Open-Close Principle.</p><p><strong>Resouces</strong></p><p><a href="https://medium.com/@rjchatfield/the-expression-problem-in-swift-6f2471291604">https://medium.com/@rjchatfield/the-expression-problem-in-swift-6f2471291604</a></p><p><a href="https://stackoverflow.com/questions/40396639/swift-extend-an-enum-for-only-one-of-its-cases">https://stackoverflow.com/questions/40396639/swift-extend-an-enum-for-only-one-of-its-cases</a></p><h3>(L) - &gt; Liskov Substitution Principle</h3><p>Objects in a program should be replaceable with instances of their subtypes without altering the correctness of that program.</p><p>Liskov's notion of a behavioural subtype defines a notion of substitutability for objects; that is, if S is a subtype of T, then objects of type T in a program may be replaced with objects of type S without altering any of the desirable properties of that program (e.g. correctness).</p><p><strong>Resouces</strong></p><p><a href="https://en.wikipedia.org/wiki/Liskov_substitution_principle">https://en.wikipedia.org/wiki/Liskov<em>substitution</em>principle</a></p><h3>(I) - &gt; Interface Segregation Principle</h3><p>Many client-specific interfaces are better than one general-purpose interface.</p><p>In the field of software engineering, the <strong><em>interface-segregation principle (ISP)</em></strong> states that no client should be forced to depend on methods it does not use. ISP splits interfaces that are very large into smaller and more specific ones so that clients will only have to know about the methods that are of interest to them. Such shrunken interfaces are also called role interfaces. ISP is intended to keep a system decoupled and thus easier to refactor, change, and redeploy.</p><p><strong>Resouces</strong></p><p><a href="https://en.wikipedia.org/wiki/Interface_segregation_principle">https://en.wikipedia.org/wiki/Interface<em>segregation</em>principle</a></p><h3>(D) - &gt; Dependency Inversion Principle</h3><p>One should "<em>depend upon abstractions, not concretions.</em>".</p><p>From SOLID, the D stand for <strong><em>Dependency Inversion</em></strong> principle. In order to handle this, the technique to follow is doing <strong><em>Dependency Injection (DI)</em></strong>. Also, DI is a good technique to avoid the use of Singletons everywhere.</p><p>In order to accomplish DI, we need/must use protocols (POP). There are, usually, 4 ways to achieve that:</p><ul><li><strong>via init</strong></li></ul><p>All the dependencies are set during the initialisation. In order to avoid having multiple parameters, we can use Swift capabilities of setting default values for the parameters. This capability allow to use the default values in production code but pass fake objects during tests.</p><ul><li><strong>via properties</strong></li></ul><p>Quite similar with the previous technique. However this force the parameters to be optional (ok, we can set default values and only set new values for testing) or we need to set all the dependencies after the init. This technique is used almost always when we are dealing with ViewControllers. This due to the fact ViewControllers initialisers works.</p><ul><li><strong>via method parameters</strong></li></ul><p>This is, in my opinion, a less suitable option.</p><ul><li><strong>via a Lib</strong></li></ul><p>Personally I don't like this option. There is a kind of black magic behind that I don't appreciate.</p><p><strong>Tools:</strong></p><ul><li>Swinject</li></ul><h4>Resources:</h4><p><a href="https://www.swiftbysundell.com/posts/different-flavors-of-dependency-injection-in-swift">https://www.swiftbysundell.com/posts/different-flavors-of-dependency-injection-in-swift</a></p><p><a href="https://www.swiftbysundell.com/posts/dependency-injection-using-factories-in-swift">https://www.swiftbysundell.com/posts/dependency-injection-using-factories-in-swift</a></p><p><a href="https://artsy.github.io/blog/2016/06/27/dependency-injection-in-swift/">https://artsy.github.io/blog/2016/06/27/dependency-injection-in-swift/</a></p><p><a href="https://www.objc.io/issues/15-testing/dependency-injection/">https://www.objc.io/issues/15-testing/dependency-injection/</a></p><p><a href="https://cocoacasts.com/nuts-and-bolts-of-dependency-injection-in-swift/">https://cocoacasts.com/nuts-and-bolts-of-dependency-injection-in-swift/</a></p><p><a href="https://codeburst.io/solid-design-principle-using-swift-fa67443672b8">https://codeburst.io/solid-design-principle-using-swift-fa67443672b8</a></p><p><a href="https://en.wikipedia.org/wiki/Dependency_inversion_principle">https://en.wikipedia.org/wiki/Dependency<em>inversion</em>principle</a></p><h2>KISS - Keep it simple, stupid!</h2><p>The <strong><em>KISS</em></strong> principle states that most systems work best if they are kept simple rather than made complicated; therefore, simplicity should be a key goal in design, and unnecessary complexity should be avoided.</p><h4>Resources:</h4><p><a href="https://en.wikipedia.org/wiki/KISS_principle">https://en.wikipedia.org/wiki/KISS_principle</a></p><h2>IAGNY - You aren't gonna need it</h2><p>A programmer should not add functionality until deemed necessary.</p><h4>Resources:</h4><p><a href="https://en.wikipedia.org/wiki/You_aren%27t_gonna_need_it">https://en.wikipedia.org/wiki/You<em>aren%27t</em>gonna<em>need</em>it</a></p><h2>DRY - Don't repeat yourself</h2><p>Don't repeat yourself is a principle of software development aimed at reducing repetition of software patterns, replacing it with abstractions or using data normalization to avoid redundancy.</p><p>The <strong><em>DRY</em></strong> principle is stated as "<em>Every piece of knowledge must have a single, unambiguous, authoritative representation within a system</em>".</p><h4>DRY vs WET solutions</h4><p>Violations of <strong><em>DRY</em></strong> are typically referred to as <strong><em>WET</em></strong> solutions, which is commonly taken to stand for either "<em>write everything twice</em>", "<em>we enjoy typing</em>" or "<em>waste everyone's time</em>".</p><p><strong><em>WET</em></strong> solutions are common in multi-tiered architectures where a developer may be tasked with, for example, adding a comment field on a form in a web application.</p><h4>Resources:</h4><p><a href="https://en.wikipedia.org/wiki/Don%27t_repeat_yourself">https://en.wikipedia.org/wiki/Don%27t<em>repeat</em>yourself</a></p><h2>GRASP</h2><p><strong><em>General Responsibility Assignment Software Patterns (or Principles)</em></strong>, consist of guidelines for assigning responsibility to classes and objects in object-oriented design. It is not related to the SOLID design principle.</p><p>The different patterns and principles used in <strong><em>GRASP</em></strong> are:</p><ul><li>controller</li><li>creator</li><li>indirection</li><li>information expert</li><li>high cohesion</li><li>low coupling</li><li>polymorphism</li><li>protected variations</li><li>pure fabrication</li></ul><p>All these patterns answer some software problems, and these problems are common to almost every software development project. These techniques have not been invented to create new ways of working, but to better document and standardize old, tried-and-tested programming principles in object-oriented design.</p><p>Computer scientist Craig Larman states that "t<em>he critical design tool for software development is a mind well educated in design principles. It is not UML or any other technology.</em>" Thus, <strong><em>GRASP</em></strong> are really a mental toolset, a learning aid to help in the design of object-oriented software.</p><h4>Resources:</h4><p><a href="https://en.wikipedia.org/wiki/GRASP_(object-oriented_design">https://en.wikipedia.org/wiki/GRASP<em>(object-oriented</em>design)</a>)</p></div><footer><p>Generated using <a href="https://github.com/johnsundell/publish">Publish</a></p><p><a href="/feed.rss">RSS feed</a></p></footer></body></html>