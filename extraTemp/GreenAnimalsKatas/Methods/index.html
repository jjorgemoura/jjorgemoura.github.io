<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"/><meta name="og:site_name" content="Cabulas"/><link rel="canonical" href="https://jjorgemoura.github.io/extraTemp/GreenAnimalsKatas/Methods"/><meta name="twitter:url" content="https://jjorgemoura.github.io/extraTemp/GreenAnimalsKatas/Methods"/><meta name="og:url" content="https://jjorgemoura.github.io/extraTemp/GreenAnimalsKatas/Methods"/><title>Testing Naming | Cabulas</title><meta name="twitter:title" content="Testing Naming | Cabulas"/><meta name="og:title" content="Testing Naming | Cabulas"/><meta name="description" content="I'm an iOS Software Engineer"/><meta name="twitter:description" content="I'm an iOS Software Engineer"/><meta name="og:description" content="I'm an iOS Software Engineer"/><meta name="twitter:card" content="summary"/><link rel="stylesheet" href="/styles.css" type="text/css"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><link rel="shortcut icon" href="/images/favicon.png" type="image/png"/><link rel="alternate" href="/feed.rss" type="application/rss+xml" title="Subscribe to Cabulas"/></head><body><header><div class="wrapper"><a href="/" class="site-name">Cabulas</a><nav><ul><li><a href="/articles">Articles</a></li><li><a href="/tips">Tips</a></li><li><a href="/posts">My posts</a></li></ul></nav></div></header><div class="wrapper"><h1>Testing Naming</h1><p>The main goal of this post is to think about the naming of testing actors. In my opinion, it seems to exist a excessive or miss used of the word <strong>Mock</strong> to represent testing or auxiliar objects.</p><p>I try to follow the naming pattern stated in Martin Fowler's article <em>Mocks Aren't Stubs</em>.</p><p>Let's have a better check.</p><h2>Naming</h2><p>Most language environments have now frameworks that make it easy to create mock objects.</p><p>From Wikipedia:</p><p>Classification between mocks, fakes, and stubs is highly inconsistent across the literature.<a href="2">1</a><a href="4">3</a><a href="6">5</a> Consistent among the literature, though, is that they all represent a production object in a testing environment by exposing the same interface.</p><p>Which out of mock, fake, or stub is the simplest is inconsistent, but the simplest always returns pre-arranged responses (as in a method stub). On the other side of the spectrum, the most complex object will fully simulate a production object with complete logic, exceptions, etc. Whether or not any of the mock, fake, or stub trio fits such a definition is, again, inconsistent across the literature.</p><p>For example, a mock, fake, or stub method implementation between the two ends of the complexity spectrum might contain assertions to examine the context of each call. For example, a mock object might assert the order in which its methods are called, or assert consistency of data across method calls.</p><p>In the book The Art of Unit Testing[7] mocks are described as a fake object that helps decide whether a test failed or passed by verifying whether an interaction with an object occurred. Everything else is defined as a stub. In that book, fakes are anything that is not real, which, based on their usage, can be either stubs or mocks.</p><p>state verification and behavior verification.</p><p>With Fake objects we are testing state. There is an initial state, do something, then I get something else.</p><h2>My take</h2><p>Fake: It works but not suitable for production/live. Could work with local data only for example.</p><p>Stub: Kind of static response, returns always the same data. No working implementation at all.</p><p>Mock:</p><p>For example, urlSession client that perform real connections is the live/production code. If there is no implementation and returns always the same canned json/data, it's a stub. If is something in between, such as returns local json/data based on different requests, it's a fake. It works, returns different data but is not the live implementation, only a basic, local only implementation.</p><h2>Conclusion</h2><p>It seems the term Mock and Mock libraries were quite popular during the Objective-C era. It was also quite popular in Java and C# and probably they still are quite popular.</p><p>It feels that with Swift, with the advent of POP (Protocol-oriented Programming), there is no need for Mock libraries because the code tend to be written in a much more testable way. Also, the use of architectures that improve testability (such as MVVM, Viper, Clean, etc) reduces the need for external use of Mock libraries the same way we were using <code>OCMock</code> and <code>OCMockito</code> the old days.</p><h2>References</h2><p><a href="https://martinfowler.com/articles/mocksArentStubs.html">Mocks Aren't Stubs - Martin Fowler</a></p></div><footer><p>Generated using <a href="https://github.com/johnsundell/publish">Publish</a></p><p><a href="/feed.rss">RSS feed</a></p></footer></body></html>